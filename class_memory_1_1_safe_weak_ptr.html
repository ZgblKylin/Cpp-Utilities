<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cpp Utilities: Memory::SafeWeakPtr&lt; T, mutex_t, read_lock_t, write_lock_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Cpp Utilities<span id="projectnumber">&#160;1.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_memory.html">Memory</a></li><li class="navelem"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="class_memory_1_1_safe_weak_ptr-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Memory::SafeWeakPtr&lt; T, mutex_t, read_lock_t, write_lock_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Wrapper to <code>std::weak_ptr</code> to provide weak reference for <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>.  
 <a href="class_memory_1_1_safe_weak_ptr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_safe_shared_ptr_8hpp_source.html">SafeSharedPtr.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a861892c155b9417a7b6f313fbb64b33c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a> = mutex_t</td></tr>
<tr class="memdesc:a861892c155b9417a7b6f313fbb64b33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for template shared_mutex_t.  <a href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">More...</a><br /></td></tr>
<tr class="separator:a861892c155b9417a7b6f313fbb64b33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09101fc26930345b2cf74e95478a7532"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a> = read_lock_t</td></tr>
<tr class="memdesc:a09101fc26930345b2cf74e95478a7532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for template read_lock_t.  <a href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">More...</a><br /></td></tr>
<tr class="separator:a09101fc26930345b2cf74e95478a7532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e13568d26dc121b9075e1f3ebdf2643"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> = write_lock_t</td></tr>
<tr class="memdesc:a9e13568d26dc121b9075e1f3ebdf2643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for template write_lock_t.  <a href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">More...</a><br /></td></tr>
<tr class="separator:a9e13568d26dc121b9075e1f3ebdf2643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537c6fd770770526341af57592e35f24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a537c6fd770770526341af57592e35f24">element_type</a> = typename <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt;::element_type</td></tr>
<tr class="memdesc:a537c6fd770770526341af57592e35f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same element_type of <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>.  <a href="class_memory_1_1_safe_weak_ptr.html#a537c6fd770770526341af57592e35f24">More...</a><br /></td></tr>
<tr class="separator:a537c6fd770770526341af57592e35f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a56c8224543ced53cfc22d31c668a3f8a"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a56c8224543ced53cfc22d31c668a3f8a">SafeWeakPtr</a> () noexcept=default</td></tr>
<tr class="memdesc:a56c8224543ced53cfc22d31c668a3f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Constructs empty weak_ptr.  <a href="class_memory_1_1_safe_weak_ptr.html#a56c8224543ced53cfc22d31c668a3f8a">More...</a><br /></td></tr>
<tr class="separator:a56c8224543ced53cfc22d31c668a3f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada42eb2aa069f1cab54cb52229d9cee1"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ada42eb2aa069f1cab54cb52229d9cee1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#ada42eb2aa069f1cab54cb52229d9cee1">SafeWeakPtr</a> (const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; Y, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:ada42eb2aa069f1cab54cb52229d9cee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> that shares an object with <code>other</code>.  <a href="class_memory_1_1_safe_weak_ptr.html#ada42eb2aa069f1cab54cb52229d9cee1">More...</a><br /></td></tr>
<tr class="separator:ada42eb2aa069f1cab54cb52229d9cee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f183890413cfe622d4e3d0516751c08"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a2f183890413cfe622d4e3d0516751c08"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a2f183890413cfe622d4e3d0516751c08">SafeWeakPtr</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:a2f183890413cfe622d4e3d0516751c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> that shares an object with <code>other</code>.  <a href="class_memory_1_1_safe_weak_ptr.html#a2f183890413cfe622d4e3d0516751c08">More...</a><br /></td></tr>
<tr class="separator:a2f183890413cfe622d4e3d0516751c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9349c4c5f2e3959b3e2a70ed1b0117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a4c9349c4c5f2e3959b3e2a70ed1b0117">~SafeWeakPtr</a> ()=default</td></tr>
<tr class="memdesc:a4c9349c4c5f2e3959b3e2a70ed1b0117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the weak_ptr object. Results in no effect to the managed object.  <a href="class_memory_1_1_safe_weak_ptr.html#a4c9349c4c5f2e3959b3e2a70ed1b0117">More...</a><br /></td></tr>
<tr class="separator:a4c9349c4c5f2e3959b3e2a70ed1b0117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b909d6a7ec8797825531875315732ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9b909d6a7ec8797825531875315732ee">operator=</a> (const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a9b909d6a7ec8797825531875315732ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with the one managed by <code>other</code>.  <a href="class_memory_1_1_safe_weak_ptr.html#a9b909d6a7ec8797825531875315732ee">More...</a><br /></td></tr>
<tr class="separator:a9b909d6a7ec8797825531875315732ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5d6cc64989f60c0faf2a8eceec2e64"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:abe5d6cc64989f60c0faf2a8eceec2e64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#abe5d6cc64989f60c0faf2a8eceec2e64">operator=</a> (const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; Y, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:abe5d6cc64989f60c0faf2a8eceec2e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with the one managed by <code>other</code>.  <a href="class_memory_1_1_safe_weak_ptr.html#abe5d6cc64989f60c0faf2a8eceec2e64">More...</a><br /></td></tr>
<tr class="separator:abe5d6cc64989f60c0faf2a8eceec2e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe32f8c86727a07c0a8d19257bdfc79f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#abe32f8c86727a07c0a8d19257bdfc79f">reset</a> () noexcept</td></tr>
<tr class="memdesc:abe32f8c86727a07c0a8d19257bdfc79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the ownership of the managed object. After the call <code>*this</code> manages no object.  <a href="class_memory_1_1_safe_weak_ptr.html#abe32f8c86727a07c0a8d19257bdfc79f">More...</a><br /></td></tr>
<tr class="separator:abe32f8c86727a07c0a8d19257bdfc79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b1b58bf122b0d344a0828f028ff157"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a74b1b58bf122b0d344a0828f028ff157">swap</a> (<a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a74b1b58bf122b0d344a0828f028ff157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of <code>*this</code> and <code>other</code>.  <a href="class_memory_1_1_safe_weak_ptr.html#a74b1b58bf122b0d344a0828f028ff157">More...</a><br /></td></tr>
<tr class="separator:a74b1b58bf122b0d344a0828f028ff157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d36236c6792077e26809fca8bc1f868"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a6d36236c6792077e26809fca8bc1f868">use_count</a> () const noexcept</td></tr>
<tr class="memdesc:a6d36236c6792077e26809fca8bc1f868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> instances that share ownership of the managed object, or 0 if the managed object has already been deleted, i.e. <code>*this</code> is empty.  <a href="class_memory_1_1_safe_weak_ptr.html#a6d36236c6792077e26809fca8bc1f868">More...</a><br /></td></tr>
<tr class="separator:a6d36236c6792077e26809fca8bc1f868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdd1288d41ba5b5225283e04e686641"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#abfdd1288d41ba5b5225283e04e686641">expired</a> () const noexcept</td></tr>
<tr class="memdesc:abfdd1288d41ba5b5225283e04e686641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the referenced object was already deleted.  <a href="class_memory_1_1_safe_weak_ptr.html#abfdd1288d41ba5b5225283e04e686641">More...</a><br /></td></tr>
<tr class="separator:abfdd1288d41ba5b5225283e04e686641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6566b256f4e2c2bbd84dde1c2acbaf9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a6566b256f4e2c2bbd84dde1c2acbaf9c">lock</a> () const noexcept</td></tr>
<tr class="memdesc:a6566b256f4e2c2bbd84dde1c2acbaf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> that manages the referenced object.  <a href="class_memory_1_1_safe_weak_ptr.html#a6566b256f4e2c2bbd84dde1c2acbaf9c">More...</a><br /></td></tr>
<tr class="separator:a6566b256f4e2c2bbd84dde1c2acbaf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18d517b24bee769ac429b5cde0a6652"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename M , typename R , typename W &gt; </td></tr>
<tr class="memitem:ae18d517b24bee769ac429b5cde0a6652"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#ae18d517b24bee769ac429b5cde0a6652">owner_before</a> (const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; Y, M, R, W &gt; &amp;other) const</td></tr>
<tr class="memdesc:ae18d517b24bee769ac429b5cde0a6652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides owner-based ordering of weak pointers.  <a href="class_memory_1_1_safe_weak_ptr.html#ae18d517b24bee769ac429b5cde0a6652">More...</a><br /></td></tr>
<tr class="separator:ae18d517b24bee769ac429b5cde0a6652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4222b4ca30d1053027485057d21ca1df"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename M , typename R , typename W &gt; </td></tr>
<tr class="memitem:a4222b4ca30d1053027485057d21ca1df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a4222b4ca30d1053027485057d21ca1df">owner_before</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y, M, R, W &gt; &amp;other) const</td></tr>
<tr class="memdesc:a4222b4ca30d1053027485057d21ca1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides owner-based ordering of weak pointers.  <a href="class_memory_1_1_safe_weak_ptr.html#a4222b4ca30d1053027485057d21ca1df">More...</a><br /></td></tr>
<tr class="separator:a4222b4ca30d1053027485057d21ca1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7908794f85e07a5817c7c163bef38aae"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename M , typename R , typename W &gt; </td></tr>
<tr class="memitem:a7908794f85e07a5817c7c163bef38aae"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a7908794f85e07a5817c7c163bef38aae">SafeSharedPtr</a></td></tr>
<tr class="separator:a7908794f85e07a5817c7c163bef38aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a4af5fd4f3529eb5569d8fe6df8391460"><td class="memTemplParams" colspan="2">template&lt;typename T , typename <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>  = Memory::shared_mutex_t, typename <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>  = Memory::shared_lock_t, typename <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a>  = Memory::unique_lock_t&gt; </td></tr>
<tr class="memitem:a4af5fd4f3529eb5569d8fe6df8391460"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a4af5fd4f3529eb5569d8fe6df8391460">swap</a> (<a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> &gt; &amp;lhs, <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a4af5fd4f3529eb5569d8fe6df8391460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the <code>std::swap</code> algorithm.  <a href="class_memory_1_1_safe_weak_ptr.html#a4af5fd4f3529eb5569d8fe6df8391460">More...</a><br /></td></tr>
<tr class="separator:a4af5fd4f3529eb5569d8fe6df8391460"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename mutex_t = shared_mutex_t, typename read_lock_t = shared_lock_t, typename write_lock_t = unique_lock_t&gt;<br />
class Memory::SafeWeakPtr&lt; T, mutex_t, read_lock_t, write_lock_t &gt;</div><p >Wrapper to <code>std::weak_ptr</code> to provide weak reference for <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object held by <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a>. </td></tr>
    <tr><td class="paramname">mutex_t</td><td>Type of the mutex used, default is shared_mutex_t. </td></tr>
    <tr><td class="paramname">read_lock_t</td><td>Type of the read-lock used, default is shared_lock_t. </td></tr>
    <tr><td class="paramname">write_lock_t</td><td>Type of the write-lock used, default is unique_lock_t.</td></tr>
  </table>
  </dd>
</dl>
<p>Same API as <code>std::weak_ptr</code>.<br  />
 See <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr">https://en.cppreference.com/w/cpp/memory/weak_ptr</a> for more details of functionalities with std::weak_ptr.<br  />
</p><dl class="section note"><dt>Note</dt><dd><b>Before C++17</b>, for the purposes of the description below, a pointer type <code>Y*</code> requires that <code>Y*</code> must be implicitly convertible to <code>T*</code>.<br  />
 <b>Since C++17</b>, for the purposes of the description below, a pointer type <code>Y*</code> is said to be <b>compatible</b> with a pointer type <code>T*</code> if either <code>Y*</code> is convertible to <code>T*</code> or <code>Y</code> is the array type <code>U[N]</code> and <code>T</code> is <code>U cv []</code> (where cv is some set of cv-qualifiers).<br  />
 <b>Since C++17</b>, default deleter called on destructor will use <code>delete[]</code> if <code>T</code> is an arry type; </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a861892c155b9417a7b6f313fbb64b33c" name="a861892c155b9417a7b6f313fbb64b33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861892c155b9417a7b6f313fbb64b33c">&#9670;&nbsp;</a></span>SharedMutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::SharedMutex =  mutex_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for template shared_mutex_t. </p>

</div>
</div>
<a id="a09101fc26930345b2cf74e95478a7532" name="a09101fc26930345b2cf74e95478a7532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09101fc26930345b2cf74e95478a7532">&#9670;&nbsp;</a></span>SharedLock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::SharedLock =  read_lock_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for template read_lock_t. </p>

</div>
</div>
<a id="a9e13568d26dc121b9075e1f3ebdf2643" name="a9e13568d26dc121b9075e1f3ebdf2643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e13568d26dc121b9075e1f3ebdf2643">&#9670;&nbsp;</a></span>UniqueLock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::UniqueLock =  write_lock_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for template write_lock_t. </p>

</div>
</div>
<a id="a537c6fd770770526341af57592e35f24" name="a537c6fd770770526341af57592e35f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537c6fd770770526341af57592e35f24">&#9670;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::element_type =  typename <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt;T&gt;::element_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same element_type of <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a56c8224543ced53cfc22d31c668a3f8a" name="a56c8224543ced53cfc22d31c668a3f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c8224543ced53cfc22d31c668a3f8a">&#9670;&nbsp;</a></span>SafeWeakPtr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::SafeWeakPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Constructs empty weak_ptr. </p>

</div>
</div>
<a id="ada42eb2aa069f1cab54cb52229d9cee1" name="ada42eb2aa069f1cab54cb52229d9cee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada42eb2aa069f1cab54cb52229d9cee1">&#9670;&nbsp;</a></span>SafeWeakPtr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::SafeWeakPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; Y, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs new <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> that shares an object with <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Element type of input weak pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Weak pointer to share object from.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs new <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> which shares an object managed by <code>other</code>. If <code>other</code> manages no object, <code>*this</code> manages no object too. </p>

</div>
</div>
<a id="a2f183890413cfe622d4e3d0516751c08" name="a2f183890413cfe622d4e3d0516751c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f183890413cfe622d4e3d0516751c08">&#9670;&nbsp;</a></span>SafeWeakPtr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::SafeWeakPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs new <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> that shares an object with <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Element type of input shared pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Shared pointer to share object from.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs new <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> which shares an object managed by <code>other</code>. If <code>other</code> manages no object, <code>*this</code> manages no object too. </p>

</div>
</div>
<a id="a4c9349c4c5f2e3959b3e2a70ed1b0117" name="a4c9349c4c5f2e3959b3e2a70ed1b0117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9349c4c5f2e3959b3e2a70ed1b0117">&#9670;&nbsp;</a></span>~SafeWeakPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::~<a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the weak_ptr object. Results in no effect to the managed object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b909d6a7ec8797825531875315732ee" name="a9b909d6a7ec8797825531875315732ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b909d6a7ec8797825531875315732ee">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; T &gt; &amp; <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with the one managed by <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Smart pointer to share an object with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>.</dd></dl>
<p>The object is shared with <code>other</code>. If <code>other</code> manages no object, <code>*this</code> manages no object too. Equivalent to <code><a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a>&lt;T&gt;(other).swap(*this)</code>. </p><dl class="section note"><dt>Note</dt><dd>The implementation may meet the requirements without creating a temporary <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> object. </dd></dl>

</div>
</div>
<a id="abe5d6cc64989f60c0faf2a8eceec2e64" name="abe5d6cc64989f60c0faf2a8eceec2e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5d6cc64989f60c0faf2a8eceec2e64">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; T &gt; &amp; <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; Y, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with the one managed by <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Element type of input pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Smart pointer to share an object with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>.</dd></dl>
<p>The object is shared with <code>other</code>. If <code>other</code> manages no object, <code>*this</code> manages no object too. Equivalent to <code><a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a>&lt;T&gt;(other).swap(*this)</code>. </p><dl class="section note"><dt>Note</dt><dd>The implementation may meet the requirements without creating a temporary <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> object. </dd></dl>

</div>
</div>
<a id="abe32f8c86727a07c0a8d19257bdfc79f" name="abe32f8c86727a07c0a8d19257bdfc79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe32f8c86727a07c0a8d19257bdfc79f">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the ownership of the managed object. After the call <code>*this</code> manages no object. </p>

</div>
</div>
<a id="a74b1b58bf122b0d344a0828f028ff157" name="a74b1b58bf122b0d344a0828f028ff157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b1b58bf122b0d344a0828f028ff157">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of <code>*this</code> and <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another weak pointer to exchange the contents with.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b><br  />
 Constant. </p>

</div>
</div>
<a id="a6d36236c6792077e26809fca8bc1f868" name="a6d36236c6792077e26809fca8bc1f868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d36236c6792077e26809fca8bc1f868">&#9670;&nbsp;</a></span>use_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> instances that share ownership of the managed object, or 0 if the managed object has already been deleted, i.e. <code>*this</code> is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> instances sharing the ownership of the managed object at the instant of the call. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_memory_1_1_safe_weak_ptr.html#abfdd1288d41ba5b5225283e04e686641" title="Checks whether the referenced object was already deleted.">expired()</a> may be faster than <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a6d36236c6792077e26809fca8bc1f868" title="Returns the number of SafeSharedPtr instances that share ownership of the managed object,...">use_count()</a>. This function is inherently racy, if the managed object is shared among threads that might be creating and destroying copies of the <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>: then, the result is reliable only if it matches the number of copies uniquely owned by the calling thread, or zero; any other value may become stale before it can be used. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_weak_ptr.html#abfdd1288d41ba5b5225283e04e686641" title="Checks whether the referenced object was already deleted.">expired</a> </dd></dl>

</div>
</div>
<a id="abfdd1288d41ba5b5225283e04e686641" name="abfdd1288d41ba5b5225283e04e686641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfdd1288d41ba5b5225283e04e686641">&#9670;&nbsp;</a></span>expired()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::expired </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the referenced object was already deleted. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the managed object has already been deleted, <code>false</code> otherwise.</dd></dl>
<p>Equivalent to <code><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a6d36236c6792077e26809fca8bc1f868" title="Returns the number of SafeSharedPtr instances that share ownership of the managed object,...">use_count()</a> == 0</code>. The destructor for the managed object may not yet have been called, but this object's destruction is imminent (or may have already happened). </p><dl class="section note"><dt>Note</dt><dd>This function is inherently racy if the managed object is shared among threads. In particular, a false result may become stale before it can be used. A true result is reliable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a6566b256f4e2c2bbd84dde1c2acbaf9c" title="Creates a SafeSharedPtr that manages the referenced object.">lock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a6d36236c6792077e26809fca8bc1f868" title="Returns the number of SafeSharedPtr instances that share ownership of the managed object,...">use_count</a> </dd></dl>

</div>
</div>
<a id="a6566b256f4e2c2bbd84dde1c2acbaf9c" name="a6566b256f4e2c2bbd84dde1c2acbaf9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6566b256f4e2c2bbd84dde1c2acbaf9c">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> that manages the referenced object. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the owned object if expired returns <code>false</code>. Else returns default-constructed <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> of type <code>T</code>.</dd></dl>
<p>Creates a new <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> that shares ownership of the managed object. If there is no managed object, i.e. <code>*this</code> is empty, then the returned <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> also is empty.\n Effectively returns <code><a class="el" href="class_memory_1_1_safe_weak_ptr.html#abfdd1288d41ba5b5225283e04e686641" title="Checks whether the referenced object was already deleted.">expired()</a> ? <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;() : <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(*this)</code>, executed atomically. </p><dl class="section note"><dt>Note</dt><dd>Both this function and the constructor of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> may be used to acquire temporary ownership of the managed object referred to by a <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a>. The difference is that the constructor of <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> throws an exception when its <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> argument is empty, while <code><a class="el" href="class_memory_1_1_safe_weak_ptr.html#a6566b256f4e2c2bbd84dde1c2acbaf9c" title="Creates a SafeSharedPtr that manages the referenced object.">lock()</a></code> constructs an empty SafeSharedPtr&lt;T&gt;. </dd></dl>

</div>
</div>
<a id="ae18d517b24bee769ac429b5cde0a6652" name="ae18d517b24bee769ac429b5cde0a6652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18d517b24bee769ac429b5cde0a6652">&#9670;&nbsp;</a></span>owner_before() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename M , typename R , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; Y, M, R, W &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides owner-based ordering of weak pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of the object managed by input pointer. </td></tr>
    <tr><td class="paramname">M</td><td>Type of the mutex used, default is shared_mutex_t. </td></tr>
    <tr><td class="paramname">R</td><td>Type of the read-lock used, default is shared_lock_t. </td></tr>
    <tr><td class="paramname">W</td><td>Type of the write-lock used, default is unique_lock_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> precedes other, <code>false</code> otherwise. Common implementations compare the addresses of the control blocks.</dd></dl>
<p>Checks whether this <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> precedes other in implementation defined owner-based (as opposed to value-based) order. The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object).<br  />
 This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less. </p>

</div>
</div>
<a id="a4222b4ca30d1053027485057d21ca1df" name="a4222b4ca30d1053027485057d21ca1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4222b4ca30d1053027485057d21ca1df">&#9670;&nbsp;</a></span>owner_before() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename M , typename R , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, mutex_t, read_lock_t, write_lock_t &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y, M, R, W &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides owner-based ordering of weak pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of the object managed by input pointer. </td></tr>
    <tr><td class="paramname">M</td><td>Type of the mutex used, default is shared_mutex_t. </td></tr>
    <tr><td class="paramname">R</td><td>Type of the read-lock used, default is shared_lock_t. </td></tr>
    <tr><td class="paramname">W</td><td>Type of the write-lock used, default is unique_lock_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> precedes other, <code>false</code> otherwise. Common implementations compare the addresses of the control blocks.</dd></dl>
<p>Checks whether this <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> precedes other in implementation defined owner-based (as opposed to value-based) order. The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object).<br  />
 This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a7908794f85e07a5817c7c163bef38aae" name="a7908794f85e07a5817c7c163bef38aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7908794f85e07a5817c7c163bef38aae">&#9670;&nbsp;</a></span>SafeSharedPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename mutex_t  = shared_mutex_t, typename read_lock_t  = shared_lock_t, typename write_lock_t  = unique_lock_t&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename M , typename R , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4af5fd4f3529eb5569d8fe6df8391460" name="a4af5fd4f3529eb5569d8fe6df8391460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af5fd4f3529eb5569d8fe6df8391460">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>  = Memory::shared_mutex_t, typename <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>  = Memory::shared_lock_t, typename <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a>  = Memory::unique_lock_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_memory_1_1_safe_weak_ptr.html">Memory::SafeWeakPtr</a>&lt; T, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a861892c155b9417a7b6f313fbb64b33c">SharedMutex</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a09101fc26930345b2cf74e95478a7532">SharedLock</a>, <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a9e13568d26dc121b9075e1f3ebdf2643">UniqueLock</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the <code>std::swap</code> algorithm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of input shared pointers. </td></tr>
    <tr><td class="paramname">SharedMutex</td><td>Type of the mutex used, default is shared_mutex_t. </td></tr>
    <tr><td class="paramname">SharedLock</td><td>Type of the read-lock used, default is shared_lock_t. </td></tr>
    <tr><td class="paramname">UniqueLock</td><td>Type of the write-lock used, default is unique_lock_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Shared pointer whose contents to swap. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another shared pointer whose contents to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>Specializes the <code>std::swap</code> algorithm for <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">Memory::SafeWeakPtr</a>. Swaps the pointers of <code>lhs</code> and <code>rhs</code>. Calls <code>lhs.swap(rhs)</code>.</p>
<p ><b>Complexity</b><br  />
 Constant. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/Utilities/MemorySafety/<a class="el" href="_safe_shared_ptr_8hpp_source.html">SafeSharedPtr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
