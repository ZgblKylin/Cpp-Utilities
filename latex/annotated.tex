\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_array_helper}{Memory\+::\+Safe\+Shared\+Ptr$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Array\+Helper$<$ Lock $>$}} \\*Proxy class for operator\mbox{[}\mbox{]} in \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}, behave like array element of underlying array object, and provide RAII read-\/write lock for thread safety }{\pageref{class_memory_1_1_safe_shared_ptr_1_1_array_helper}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Memory\+::\+Enable\+Safe\+Shared\+From\+This$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$}} \\*A proxy class from {\ttfamily std\+::enable\+\_\+shared\+\_\+from\+\_\+this} to provide same functionality for \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} }{\pageref{class_memory_1_1_enable_safe_shared_from_this}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1iterator__base}{Container\+::\+Sequencial\+Map$<$ Key, T, Compare, Allocator $>$\+::iterator\+\_\+base$<$ constant $>$}} \\*Base type for iterators }{\pageref{struct_container_1_1_sequencial_map_1_1iterator__base}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1key__iterator}{Container\+::\+Sequencial\+Map$<$ Key, T, Compare, Allocator $>$\+::key\+\_\+iterator}} \\*Iterator to traverse keys }{\pageref{struct_container_1_1_sequencial_map_1_1key__iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ptr_helper}{Memory\+::\+Safe\+Shared\+Ptr$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Ptr\+Helper$<$ Lock $>$}} \\*Proxy class for operator-\/\texorpdfstring{$>$}{>} in \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}, behave like underlying object, and provide RAII read-\/write lock for thread safety }{\pageref{class_memory_1_1_safe_shared_ptr_1_1_ptr_helper}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_dimensional_1_1_quantity}{Dimensional\+::\+Quantity$<$ T, U, Ratio $>$}} \\*The \mbox{\hyperlink{class_dimensional_1_1_quantity}{Quantity}} struct is used to describe arithmetic values with units }{\pageref{class_dimensional_1_1_quantity}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_memory_1_1_r_w_spin_lock_1_1_read_holder}{Memory\+::\+RWSpin\+Lock\+::\+Read\+Holder}} \\*RAII guard for read lock with \mbox{\hyperlink{class_memory_1_1_r_w_spin_lock_afd7f0984624001c03258bee4354e8388}{RWSpin\+Lock\+::lock\+\_\+shared()}} on construction and \mbox{\hyperlink{class_memory_1_1_r_w_spin_lock_a8ce7c822fdb5e9c3b5997e77186ef2ad}{RWSpin\+Lock\+::unlock\+\_\+shared()}} on destruction }{\pageref{class_memory_1_1_r_w_spin_lock_1_1_read_holder}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ref_helper}{Memory\+::\+Safe\+Shared\+Ptr$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Ref\+Helper$<$ Lock $>$}} \\*Proxy class for operator$\ast$ in \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}, behave like underlying object, and provide RAII read-\/write lock for thread safety }{\pageref{class_memory_1_1_safe_shared_ptr_1_1_ref_helper}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_memory_1_1_r_w_spin_lock}{Memory\+::\+RWSpin\+Lock}} \\*High-\/performance read-\/write-\/spinlock, see \mbox{\hyperlink{_r_w_spin_lock_8hpp}{RWSpin\+Lock.\+hpp}} for details }{\pageref{class_memory_1_1_r_w_spin_lock}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$}} \\*Wrapper to {\ttfamily std\+::shared\+\_\+ptr} to provide thread-\/safety while operating the underlying pointer }{\pageref{class_memory_1_1_safe_shared_ptr}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Memory\+::\+Safe\+Weak\+Ptr$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$}} \\*Wrapper to {\ttfamily std\+::weak\+\_\+ptr} to provide weak reference for \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} }{\pageref{class_memory_1_1_safe_weak_ptr}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map$<$ Key, T, Compare, Allocator $>$}} \\*Key-\/value container behaves like std\+::map, but extended with random-\/access operations and traverses in the sequence order of value appends like {\ttfamily std\+::vector} }{\pageref{class_container_1_1_sequencial_map}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1_serialize_manipulator}{Container\+::\+Sequencial\+Map$<$ Key, T, Compare, Allocator $>$\+::\+Serialize\+Manipulator}} \\*Stream manipulator for serialization and deserialization }{\pageref{struct_container_1_1_sequencial_map_1_1_serialize_manipulator}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_dimensional_1_1_unit}{Dimensional\+::\+Unit$<$ length, mass, time, current, temperature, amount\+Of\+Substance, luminous\+Intensity $>$}} \\*The \mbox{\hyperlink{struct_dimensional_1_1_unit}{Unit}} struct is used to describe physical units }{\pageref{struct_dimensional_1_1_unit}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_memory_1_1_r_w_spin_lock_1_1_upgraded_holder}{Memory\+::\+RWSpin\+Lock\+::\+Upgraded\+Holder}} \\*RAII guard for upgrade lock with \mbox{\hyperlink{class_memory_1_1_r_w_spin_lock_a318a4d4b4f3dc8f6fb4d8c07f15956e7}{RWSpin\+Lock\+::lock\+\_\+upgrade()}} on construction and \mbox{\hyperlink{class_memory_1_1_r_w_spin_lock_a0fefc1cc0184d89dc778b5a63903923e}{RWSpin\+Lock\+::unlock\+\_\+upgrade()}} on destruction }{\pageref{class_memory_1_1_r_w_spin_lock_1_1_upgraded_holder}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_memory_1_1_r_w_spin_lock_1_1_write_holder}{Memory\+::\+RWSpin\+Lock\+::\+Write\+Holder}} \\*RAII guard for write lock with \mbox{\hyperlink{class_memory_1_1_r_w_spin_lock_a8910cf79fa5d02530a57b239f15749a1}{RWSpin\+Lock\+::lock()}} on construction and \mbox{\hyperlink{class_memory_1_1_r_w_spin_lock_ae3aca9f278ce35c12300c8159e9e898e}{RWSpin\+Lock\+::unlock()}} on destruction }{\pageref{class_memory_1_1_r_w_spin_lock_1_1_write_holder}}{}
\end{DoxyCompactList}
