\hypertarget{class_container_1_1_sequencial_map}{}\doxysection{Container\+::Sequencial\+Map\texorpdfstring{$<$}{<} Key, T, Compare, Allocator \texorpdfstring{$>$}{>} Class Template Reference}
\label{class_container_1_1_sequencial_map}\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}


Key-\/value container behaves like std\+::map, but extended with random-\/access operations and traverses in the sequence order of value appends like {\ttfamily std\+::vector}.  




{\ttfamily \#include $<$Sequencial\+Map.\+hpp$>$}

\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1iterator__base}{iterator\+\_\+base}}
\begin{DoxyCompactList}\small\item\em Base type for iterators. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1key__iterator}{key\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Iterator to traverse keys. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1_serialize_manipulator}{Serialize\+Manipulator}}
\begin{DoxyCompactList}\small\item\em Stream manipulator for serialization and deserialization. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_a7c95d3b16babee88ec456a8bb1eb7248}{allocator\+\_\+type}} = Allocator
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_aacf3b0619b0184ee2721ca5ff77d917b}{map\+\_\+type}} = std\+::map$<$ Key, T, Compare, Allocator $>$
\begin{DoxyCompactList}\small\item\em Underlying map type for map APIs. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_a220604b02cf35b542050f191c65d76d1}{vector\+\_\+type}} = std\+::vector$<$ typename map\+\_\+type\+::iterator $>$
\begin{DoxyCompactList}\small\item\em Underlying map type for random-\/access operations and sequencial traversal. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} = typename map\+\_\+type\+::key\+\_\+type
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_adb3f5183cdc35b3a6b452a03d66a1fd5}{mapped\+\_\+type}} = typename map\+\_\+type\+::mapped\+\_\+type
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_ac1eed887c3ab20dc88f4351136454566}{key\+\_\+compare}} = typename map\+\_\+type\+::key\+\_\+compare
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_a5175f2a97a1cdf02bdcd65130410d428}{value\+\_\+compare}} = typename map\+\_\+type\+::value\+\_\+compare
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} = typename map\+\_\+type\+::value\+\_\+type
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_a9f8f9891deaafece7e66b44696a6d37b}{pointer}} = typename map\+\_\+type\+::pointer
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_a422ded613b3173982d7b303974f76182}{const\+\_\+pointer}} = typename map\+\_\+type\+::const\+\_\+pointer
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_afff4523f78165d54760940fd9adb616e}{reference}} = typename map\+\_\+type\+::reference
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}} = typename map\+\_\+type\+::const\+\_\+reference
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} = typename map\+\_\+type\+::size\+\_\+type
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_a37963b4a5251896ca414b670e1e2175c}{difference\+\_\+type}} = typename map\+\_\+type\+::difference\+\_\+type
\begin{DoxyCompactList}\small\item\em Provide same member type of {\ttfamily std\+::map}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} = \mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1iterator__base}{iterator\+\_\+base}}$<$ false $>$
\begin{DoxyCompactList}\small\item\em Mutable iterator type for {\ttfamily Legacy\+Random\+Access\+Iterator}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} = \mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1iterator__base}{iterator\+\_\+base}}$<$ true $>$
\begin{DoxyCompactList}\small\item\em Immutable iterator type for constant {\ttfamily Legacy\+Random\+Access\+Iterator}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_a030f29381886011469fe1cd6543179ca}{reverse\+\_\+iterator}} = std\+::reverse\+\_\+iterator$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} $>$
\begin{DoxyCompactList}\small\item\em Mutable reverse iterator type. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}{const\+\_\+reverse\+\_\+iterator}} = std\+::reverse\+\_\+iterator$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} $>$
\begin{DoxyCompactList}\small\item\em Immutable reverse iterator type. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_container_1_1_sequencial_map_a22b824422131d09fe11bb466fec2ca6c}{reverse\+\_\+key\+\_\+iterator}} = std\+::reverse\+\_\+iterator$<$ \mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1key__iterator}{key\+\_\+iterator}} $>$
\begin{DoxyCompactList}\small\item\em Reverse iterator to traverse keys. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_a1da133cd9d46c51a2616ec066c825388}{Sequencial\+Map}} ()
\begin{DoxyCompactList}\small\item\em Default constructor, constructs an empty container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_a2f5a4bf5422199b648d188381399aab5}{Sequencial\+Map}} (const Compare \&comp, const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Constructs an empty container with given comparator and allocator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Input\+It $>$ }\\\mbox{\hyperlink{class_container_1_1_sequencial_map_a82bfbf809ffef3c20d7467c13b1222b6}{Sequencial\+Map}} (Input\+It first, Input\+It last, const Compare \&comp=Compare(), const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Constructs the container with the contents of the range {\ttfamily \mbox{[}first, last)}. If multiple elements in the range have keys that compare equivalent, only the first element is inserted. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Input\+It $>$ }\\\mbox{\hyperlink{class_container_1_1_sequencial_map_a2aa594ab3466dba8a92357452e060834}{Sequencial\+Map}} (Input\+It first, Input\+It last, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Constructs the container with the contents of the range {\ttfamily \mbox{[}first, last)}. If multiple elements in the range have keys that compare equivalent, only the first element is inserted. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_abb2dad8e14a2caeb3844e47f26ae7dc0}{Sequencial\+Map}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other, const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Copy constructor. Constructs the container with the copy of the contents of {\ttfamily other}. If {\ttfamily alloc} is not provided, allocator is obtained by calling \`{}\`{}\`{}cpp std\+::allocator\+\_\+traits$<$allocator\+\_\+type$>$\+::select\+\_\+on\+\_\+container\+\_\+copy\+\_\+construction(other.\+get\+\_\+allocator()) \`{}\`{}\`{}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_af49228c98db799e81c6fa6b5824db0d8}{Sequencial\+Map}} (\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&\&other, const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Move constructor. Constructs the container with the contents of {\ttfamily other} using move semantics. If alloc is not provided, allocator is obtained by move-\/construction from the allocator belonging to {\ttfamily other}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_a1c601b369514f03390e87caba773f0a6}{Sequencial\+Map}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} $>$ init, const Compare \&comp=Compare(), const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Constructs the container with the contents of the initializer list {\ttfamily init}. If multiple elements in the range have keys that compare equivalent, only the first element is inserted. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_abef6363671b5cc82d105b136760e8161}{$\sim$\+Sequencial\+Map}} ()=default
\begin{DoxyCompactList}\small\item\em Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-\/to objects are not destroyed. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_a7c95d3b16babee88ec456a8bb1eb7248}{allocator\+\_\+type}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a3facc9509209b82ef996764e395ce018}{get\+\_\+allocator}} () const
\begin{DoxyCompactList}\small\item\em Returns the allocator associated with the container. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_container_1_1_sequencial_map_a10b4eadfd412de264780e977b0f88ac1}{empty}} () const noexcept
\begin{DoxyCompactList}\small\item\em Checks if the container has no elements, i.\+e. whether {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef14f6ec882277082f2caf161076979c}{begin()}} == \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the number of elements in the container, i.\+e. {\ttfamily std\+::distance(\mbox{\hyperlink{class_container_1_1_sequencial_map_aef14f6ec882277082f2caf161076979c}{begin()}}, \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}})}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a545b66155f26b357fadecec41aef5748}{max\+\_\+size}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.\+e. {\ttfamily std\+::distance(\mbox{\hyperlink{class_container_1_1_sequencial_map_aef14f6ec882277082f2caf161076979c}{begin()}}, \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}})} for the largest container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_container_1_1_sequencial_map_ad2f44dfd27fa008b4b7f2276422b6a13}{clear}} () noexcept
\item 
bool \mbox{\hyperlink{class_container_1_1_sequencial_map_a953b176f0e005d7076cfb790c9f2c1f3}{contains}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}) const
\begin{DoxyCompactList}\small\item\em Checks if there is an element with key equivalent to key in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a2ed22123549126ebab18333bfe27350a}{find}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}})
\begin{DoxyCompactList}\small\item\em Finds an element with key equivalent to key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ac2fed678f1ad1cdffc9d5443dc22f340}{find}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}) const
\begin{DoxyCompactList}\small\item\em Finds an element with key equivalent to key. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Container  = std\+::vector$<$key\+\_\+type$>$$>$ }\\Container \mbox{\hyperlink{class_container_1_1_sequencial_map_abd3d6d895e0cf5aea8e7cb1be4cbb917}{keys}} () const
\begin{DoxyCompactList}\small\item\em Returns a list containing all the keys in the map in the sequence order of value appends. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}} (const T \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}}, const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&default\+Key=\mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}}()) const
\begin{DoxyCompactList}\small\item\em Returns the key with value {\ttfamily value}, or {\ttfamily default\+Key} if the map contains no item with value {\ttfamily value}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Container  = std\+::vector$<$\+T$>$$>$ }\\Container \mbox{\hyperlink{class_container_1_1_sequencial_map_a9e489cafcef3cbe5b1e1a4a963293283}{values}} () const
\begin{DoxyCompactList}\small\item\em Returns a list containing all the values in the map in the sequence order of value appends. \end{DoxyCompactList}\item 
const T \& \mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, const T \&default\+Value=T()) const
\begin{DoxyCompactList}\small\item\em Returns the value associated with the key {\ttfamily key}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_afff4523f78165d54760940fd9adb616e}{reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ab4ee6ee6544815e2d0627e3e4c60b445}{at}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} pos)
\begin{DoxyCompactList}\small\item\em Returns a reference to the element at specified location {\ttfamily pos}, with bounds checking. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a6653019c05b42c36dd8233833a77707e}{at}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} pos) const
\begin{DoxyCompactList}\small\item\em Returns a const reference to the element at specified location {\ttfamily pos}, with bounds checking. \end{DoxyCompactList}\item 
T \& \mbox{\hyperlink{class_container_1_1_sequencial_map_a6f957c4ba9cef3ace6be3677bdade88c}{operator\mbox{[}$\,$\mbox{]}}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}})
\begin{DoxyCompactList}\small\item\em Returns a reference to the value that is mapped to a key equivalent to {\ttfamily key}, performing an insertion if such key does not already exist. \end{DoxyCompactList}\item 
T \& \mbox{\hyperlink{class_container_1_1_sequencial_map_a77ffaba89016def1c4548003278dce37}{operator\mbox{[}$\,$\mbox{]}}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}})
\begin{DoxyCompactList}\small\item\em Returns a reference to the value that is mapped to a key equivalent to {\ttfamily key}, performing an insertion if such key does not already exist. \end{DoxyCompactList}\item 
const T \mbox{\hyperlink{class_container_1_1_sequencial_map_a96e37928161fded8d073e692c14c8452}{operator\mbox{[}$\,$\mbox{]}}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}) const
\begin{DoxyCompactList}\small\item\em Returns a copy to the value that is mapped to a key equivalent to {\ttfamily key}, return a default constructed value if such key does not already exist. \end{DoxyCompactList}\item 
const T \mbox{\hyperlink{class_container_1_1_sequencial_map_a5b9a3adb05dcd295a4fce86a00c042bf}{operator\mbox{[}$\,$\mbox{]}}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}) const
\begin{DoxyCompactList}\small\item\em Returns a copy to the value that is mapped to a key equivalent to {\ttfamily key}, return a default constructed value if such key does not already exist. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_afff4523f78165d54760940fd9adb616e}{reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a66dfa719b3a57e06e00570ee418709d6}{front}} ()
\begin{DoxyCompactList}\small\item\em Returns a reference to the first element in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a1bd8f7e51ccbd91a9eee4dbc19b5027b}{front}} () const
\begin{DoxyCompactList}\small\item\em Returns a const reference to the first element in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_afff4523f78165d54760940fd9adb616e}{reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a167ec50bc2792f6187b56db4b05057a5}{back}} ()
\begin{DoxyCompactList}\small\item\em Returns a reference to the last element in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a8576a0f43e8e0985d53ffb9631b26c73}{back}} () const
\begin{DoxyCompactList}\small\item\em Returns a const reference to the last element in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ab9299268be76fe14a653b2239f62a8cf}{mid}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} pos) const
\begin{DoxyCompactList}\small\item\em Returns a sub-\/map which contains elements from this map, starting at position {\ttfamily pos} to the end. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a1eeeb3a4862fb9ae342c7402ecda99bf}{mid}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} pos, \mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} length) const
\begin{DoxyCompactList}\small\item\em Returns a sub-\/map which contains elements from this map, starting at position {\ttfamily pos}, with {\ttfamily length} elements (or all remaining elements if there are less than {\ttfamily length} elements) are included. \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aa9c04c3f3cf92f650884f8db731c955f}{push\+\_\+back}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Appends the given element value to the end of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map_a507de063789bd85633eeac5cddd5f23e}{push\+\_\+back}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Appends the given element value to the end of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aaeab76ed2c5a032d01b19ae85ffef3fd}{push\+\_\+back}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, const T \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Appends the given element value to the end of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aaac583a4f64517d3a1d5bce90f5824a3}{push\+\_\+back}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, T \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Appends the given element value to the end of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_container_1_1_sequencial_map_aef2b45bd3200f3b6b43679aa3b66cfeb}{push\+\_\+back}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other)
\begin{DoxyCompactList}\small\item\em Appends all elements from given container {\ttfamily other} to the end of the container, ignores all values with keys already exists in the container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_container_1_1_sequencial_map_ae300f91bdfb9d9d84c416377ee62d44a}{push\+\_\+back}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} $>$ ilist)
\begin{DoxyCompactList}\small\item\em Appends all elements from initializer list {\ttfamily ilist} to the end of the container, ignores all values with keys already exists in the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Input\+It $>$ }\\void \mbox{\hyperlink{class_container_1_1_sequencial_map_aa6bb62e84cf18052f75353e7204532b3}{push\+\_\+back}} (Input\+It first, Input\+It last)
\begin{DoxyCompactList}\small\item\em Appends all elements from from range {\ttfamily \mbox{[}first, last)} to the end of the container, ignores all values with keys already exists in the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map_af6c31832814c5cc8f213cf07283e20c4}{emplace\+\_\+back}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Appends a new element to the end of the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aa2ac071829ff30c8e2d6fee7d9ba0d01}{emplace\+\_\+back}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Appends a new element to the end of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a24b3e7e1f562f390b9b98d14e87e3106}{operator+}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other) const
\begin{DoxyCompactList}\small\item\em Same as push\+\_\+back, appends all elements from given container {\ttfamily other} to the end of the container, ignores all values with keys already exists in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \mbox{\hyperlink{class_container_1_1_sequencial_map_acdaa1421a064756c48e3f6800a29da6f}{operator+}} (\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&\&other) const
\begin{DoxyCompactList}\small\item\em Same as push\+\_\+back, appends all elements from given container {\ttfamily other} to the end of the container, ignores all values with keys already exists in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \& \mbox{\hyperlink{class_container_1_1_sequencial_map_aaa688b7dba614eeeefc060c39d7762c5}{operator+=}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other)
\begin{DoxyCompactList}\small\item\em Same as push\+\_\+back, appends all elements from given container {\ttfamily other} to the end of the container and return {\ttfamily $\ast$this}, ignores all values with keys already exists in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \& \mbox{\hyperlink{class_container_1_1_sequencial_map_ab6f6fb831976434f3f0b017acd5dd181}{operator+=}} (\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&\&other)
\begin{DoxyCompactList}\small\item\em Same as push\+\_\+back, appends all elements from given container {\ttfamily other} to the end of the container and return {\ttfamily $\ast$this}, ignores all values with keys already exists in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a4589c7bf8eabbe0eea7fde131697d10f}{insert}} (size\+\_\+t pos, \mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_acb0a716f543c72ee5e511cc02f2ba218}{insert}} (size\+\_\+t pos, \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_afe54be787d18ce2faa0857edc118c5c4}{insert}} (size\+\_\+t pos, const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, const T \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a325b440c50f6464cc03ddea347b02423}{insert}} (size\+\_\+t pos, const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, T \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a4023b4dfcb55a7b50e0f8f265596835d}{insert}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} pos, \mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ae1fb7451d113ac2079426f34853017d8}{insert}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} pos, \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a810c34904f9ec5e27046bc7fab459692}{insert}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} pos, const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, const T \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a814f2c8132f8c84cc82416cc5e4fc68d}{insert}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} pos, const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, T \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}})
\begin{DoxyCompactList}\small\item\em Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Input\+It $>$ }\\void \mbox{\hyperlink{class_container_1_1_sequencial_map_aa3590d08d1b7a66b998a051222eb4db9}{insert}} (size\+\_\+t pos, Input\+It first, Input\+It last)
\begin{DoxyCompactList}\small\item\em Inserts elements into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_container_1_1_sequencial_map_ae1f9d51140e3df712a0ffbcc5372d946}{insert}} (size\+\_\+t pos, std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} $>$ ilist)
\begin{DoxyCompactList}\small\item\em Inserts elements into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Input\+It $>$ }\\void \mbox{\hyperlink{class_container_1_1_sequencial_map_aa1ec0d24659db8cc21a683799486b8f7}{insert}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} pos, Input\+It first, Input\+It last)
\begin{DoxyCompactList}\small\item\em Inserts elements into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_container_1_1_sequencial_map_a3f4b3a1ebf98b8ccfccf2ae97a0f8918}{insert}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} pos, std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} $>$ ilist)
\begin{DoxyCompactList}\small\item\em Inserts elements into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map_a7c6d257953580c6aa2f16e6f249fbb88}{emplace\+\_\+at}} (size\+\_\+t pos, const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Inserts a new element to the container as close as possible to the position just before hint. The element is constructed in-\/place, i.\+e. no copy or move operations are performed. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ada599a623dfa4ae4edece8633cfc4543}{emplace\+\_\+at}} (size\+\_\+t pos, \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Inserts a new element to the container as close as possible to the position just before hint. The element is constructed in-\/place, i.\+e. no copy or move operations are performed. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a516e726fdf4060fa02459ba7f2dae636}{emplace\+\_\+hint}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} hint, \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}}, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Inserts a new element to the container as close as possible to the position just before hint. The element is constructed in-\/place, i.\+e. no copy or move operations are performed. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_container_1_1_sequencial_map_a424271f056077ab91d8606eee478d2b1}{pop\+\_\+back}} ()
\begin{DoxyCompactList}\small\item\em Removes the last element of the container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_container_1_1_sequencial_map_ad090ad2af2de3754b994334c95b0ae4a}{erase}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}})
\begin{DoxyCompactList}\small\item\em Removes specified element from the container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_container_1_1_sequencial_map_a03e77d46c8262ea533eb96cd2d096675}{erase}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} pos, \mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} count=1)
\begin{DoxyCompactList}\small\item\em Removes specified elements from the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a42d1128d6f2cceef29f396fe099079e5}{erase}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} pos)
\begin{DoxyCompactList}\small\item\em Removes specified elements from the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a4d68d6ec7a221315e9eaa97657bfcbb9}{erase}} (\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} first, \mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} last)
\begin{DoxyCompactList}\small\item\em Removes specified elements from the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_aef14f6ec882277082f2caf161076979c}{begin}} ()
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the container.~\newline
 If the container is empty, the returned iterator will be equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ac2af7db2d9fda74eb54571529e9796a9}{begin}} () const
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the container.~\newline
 If the container is empty, the returned iterator will be equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a3592bd4767d34231685cde1571d2ed67}{cbegin}} () const
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the container.~\newline
 If the container is empty, the returned iterator will be equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end}} ()
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the container.~\newline
 This element acts as a placeholder; attempting to access it results in undefined behavior. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a1ad471e4549a73f8df09e5a3391611ce}{end}} () const
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the container.~\newline
 This element acts as a placeholder; attempting to access it results in undefined behavior. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_af8361df6d13eb856284108334ac0c48d}{cend}} () const
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the container.~\newline
 This element acts as a placeholder; attempting to access it results in undefined behavior. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_a030f29381886011469fe1cd6543179ca}{reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a4cf6f207f8ab3a88ed385b4f6262c6a7}{rbegin}} ()
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-\/reversed container. If the container is empty, the returned iterator is equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}{rend()}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a949f75dea4be0ac64f366585def14b2c}{rbegin}} () const
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-\/reversed container. If the container is empty, the returned iterator is equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}{rend()}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a9de19811bfac99acea78d980ccb51347}{crbegin}} () const
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-\/reversed container. If the container is empty, the returned iterator is equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}{rend()}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_a030f29381886011469fe1cd6543179ca}{reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}{rend}} ()
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-\/reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a0835201ee559bc74afef9984de8c168c}{rend}} () const
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-\/reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a3781a9637382321983fe00744eb5cf6a}{crend}} () const
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-\/reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1key__iterator}{key\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ae56f83636910a5b07f9869b0129cb915}{key\+\_\+begin}} () const
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first key of the container.~\newline
 If the container is empty, the returned iterator will be equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1key__iterator}{key\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_ac1e3bf5bc5dcbb632ed1948a1cea6ad8}{key\+\_\+end}} () const
\begin{DoxyCompactList}\small\item\em Returns an iterator to the key following the last key of the container.~\newline
 This key acts as a placeholder; attempting to access it results in undefined behavior. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_a22b824422131d09fe11bb466fec2ca6c}{reverse\+\_\+key\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a83a5fc05a8661510d2678dd9af7c2538}{key\+\_\+rbegin}} () const
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first key of the reversed container. It corresponds to the last key of the non-\/reversed container. If the container is empty, the returned iterator is equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}{rend()}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_a22b824422131d09fe11bb466fec2ca6c}{reverse\+\_\+key\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a8455670da4cc5643d53a0242d86cdd6f}{key\+\_\+rend}} () const
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the key following the last key of the reversed container. It corresponds to the key preceding the first key of the non-\/reversed container. This key acts as a placeholder, attempting to access it results in undefined behavior. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \& \mbox{\hyperlink{class_container_1_1_sequencial_map_a08b287718cdbd0b455677010229f08b6}{operator=}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other)
\begin{DoxyCompactList}\small\item\em Replaces the contents of the input container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \& \mbox{\hyperlink{class_container_1_1_sequencial_map_a553598ddda9393bb612e96c4f38fce9e}{operator=}} (\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&\&other)
\begin{DoxyCompactList}\small\item\em Replaces the contents of the input container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \& \mbox{\hyperlink{class_container_1_1_sequencial_map_a610f956474fc138e8aabc63e81a25773}{operator=}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} $>$ ilist)
\begin{DoxyCompactList}\small\item\em Replaces the contents of the input container. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_container_1_1_sequencial_map_ae7fd4a84c02afff57265d0c8bd775243}{operator==}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other) const
\begin{DoxyCompactList}\small\item\em Checks if the contents of two containers are not equal. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_container_1_1_sequencial_map_aea0b7cfcab6177efacd4350a2fae1535}{operator!=}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other) const
\begin{DoxyCompactList}\small\item\em Checks if the contents of two containers are equal, that is,. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_container_1_1_sequencial_map_ad0ddfdc46ecf31066968bdb88a2fb95c}{operator$<$}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other) const
\begin{DoxyCompactList}\small\item\em Compares the contents of two containers lexicographically. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_container_1_1_sequencial_map_a839e416ce19751824abcdeefc85cdccd}{operator$<$=}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other) const
\begin{DoxyCompactList}\small\item\em Compares the contents of two containers lexicographically. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_container_1_1_sequencial_map_a24644885c1fc45f55295def91b435d65}{operator$>$}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other) const
\begin{DoxyCompactList}\small\item\em Compares the contents of two containers lexicographically. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_container_1_1_sequencial_map_a3090d37e36bfef54b9002f36f90f0db9}{operator$>$=}} (const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other) const
\begin{DoxyCompactList}\small\item\em Compares the contents of two containers lexicographically. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_container_1_1_sequencial_map_a17bf11c644ff3f9f901623a9e00628ab}{swap}} (\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&other)
\begin{DoxyCompactList}\small\item\em Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac1eed887c3ab20dc88f4351136454566}{key\+\_\+compare}} \mbox{\hyperlink{class_container_1_1_sequencial_map_adccc65fb868b9eb7c2215ba38638e0eb}{key\+\_\+comp}} () const
\begin{DoxyCompactList}\small\item\em Returns the function object that compares the keys, which is a copy of this container\textquotesingle{}s constructor argument comp. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_container_1_1_sequencial_map_a5175f2a97a1cdf02bdcd65130410d428}{value\+\_\+compare}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a74870be561b4907ac985f21d62419d29}{value\+\_\+comp}} () const
\begin{DoxyCompactList}\small\item\em Returns a function object that compares objects of type {\ttfamily std\+::map\+::value\+\_\+type} (key-\/value pairs) by using {\ttfamily key\+\_\+comp} to compare the first components of the pairs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1_serialize_manipulator}{Serialize\+Manipulator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_a447011ae320fa1a14c979d18e7848d56}{serialize}} () const
\begin{DoxyCompactList}\small\item\em Serialize the contents to output stream. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1_serialize_manipulator}{Serialize\+Manipulator}} \mbox{\hyperlink{class_container_1_1_sequencial_map_aecf2617bf43cf5dd18f6f2b5b5e0dc93}{deserialize}} ()
\begin{DoxyCompactList}\small\item\em Deserialize the contents from input stream. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Stream $>$ }\\Stream \& \mbox{\hyperlink{class_container_1_1_sequencial_map_a9a3682f82d469079b8257792879f1c60}{operator$<$$<$}} (Stream \&out, const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \&map)
\begin{DoxyCompactList}\small\item\em Writes the contents of list to output stream. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Related Functions}
(Note that these are not member functions.) \begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ }\\void \mbox{\hyperlink{class_container_1_1_sequencial_map_aa4c0db5a6c160748a0dafee7b258d1bc}{swap}} (\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&lhs, \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Specializes the {\ttfamily std\+::swap} algorithm. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Key , class T , class Compare , class Alloc , class Pred $>$ }\\void \mbox{\hyperlink{class_container_1_1_sequencial_map_a35bbbdc21a0b30f8b70df82046c65b66}{erase\+\_\+if}} (\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Alloc $>$ \&c, Pred pred)
\begin{DoxyCompactList}\small\item\em Erases all elements that satisfy the predicate pred from the container. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Key, typename T, typename Compare = std\+::less$<$\+Key$>$, typename Allocator = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$\newline
class Container\+::\+Sequencial\+Map$<$ Key, T, Compare, Allocator $>$}
Key-\/value container behaves like std\+::map, but extended with random-\/access operations and traverses in the sequence order of value appends like {\ttfamily std\+::vector}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Key} & Key type of input maps. \\
\hline
{\em T} & Value type of input maps. \\
\hline
{\em Compare} & Comparison function object to use for all comparisons of keys. \\
\hline
{\em Allocator} & Allocator to use for all memory allocations of this container.\\
\hline
\end{DoxyTemplParams}
Same API as {\ttfamily std\+::map}, but add more APIs from {\ttfamily std\+::vector} to extend random-\/access operations.~\newline
 All iterators and random-\/access operations traverse the map in the sequence of value appends like {\ttfamily std\+::vector}.~\newline
 ~\newline
 {\bfseries{Iterator and Reference Invalidation}}~\newline
 Iterator invalidation of modify operations behave like {\ttfamily std\+::vector}.~\newline
 Reference invalidation of modify operations behave like {\ttfamily std\+::map}.~\newline
 ~\newline
 {\bfseries{Algorithmic Complexity}}~\newline
 Most operations of \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} have the same algorithmic complexity as {\ttfamily std\+::map}, while random-\/access operations share the same complexity as {\ttfamily std\+::vector}.~\newline

\begin{DoxyItemize}
\item Key lookup\+: O(log {\itshape n})
\item Index lookup\+: O(1)
\item Insertion/\+Erase\+: O({\itshape n}) (Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node.)
\item Appending\+: O(log {\itshape n}) 
\end{DoxyItemize}

\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_a7c95d3b16babee88ec456a8bb1eb7248}\label{class_container_1_1_sequencial_map_a7c95d3b16babee88ec456a8bb1eb7248}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!allocator\_type@{allocator\_type}}
\index{allocator\_type@{allocator\_type}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{allocator\_type}{allocator\_type}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::allocator\+\_\+type =  Allocator}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_aacf3b0619b0184ee2721ca5ff77d917b}\label{class_container_1_1_sequencial_map_aacf3b0619b0184ee2721ca5ff77d917b}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!map\_type@{map\_type}}
\index{map\_type@{map\_type}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{map\_type}{map\_type}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::map\+\_\+type =  std\+::map$<$Key, T, Compare, Allocator$>$}



Underlying map type for map APIs. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_a220604b02cf35b542050f191c65d76d1}\label{class_container_1_1_sequencial_map_a220604b02cf35b542050f191c65d76d1}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!vector\_type@{vector\_type}}
\index{vector\_type@{vector\_type}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{vector\_type}{vector\_type}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::vector\+\_\+type =  std\+::vector$<$typename map\+\_\+type\+::iterator$>$}



Underlying map type for random-\/access operations and sequencial traversal. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}\label{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!key\_type@{key\_type}}
\index{key\_type@{key\_type}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{key\_type}{key\_type}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::key\+\_\+type =  typename map\+\_\+type\+::key\+\_\+type}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_adb3f5183cdc35b3a6b452a03d66a1fd5}\label{class_container_1_1_sequencial_map_adb3f5183cdc35b3a6b452a03d66a1fd5}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!mapped\_type@{mapped\_type}}
\index{mapped\_type@{mapped\_type}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{mapped\_type}{mapped\_type}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::mapped\+\_\+type =  typename map\+\_\+type\+::mapped\+\_\+type}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_ac1eed887c3ab20dc88f4351136454566}\label{class_container_1_1_sequencial_map_ac1eed887c3ab20dc88f4351136454566}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!key\_compare@{key\_compare}}
\index{key\_compare@{key\_compare}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{key\_compare}{key\_compare}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::key\+\_\+compare =  typename map\+\_\+type\+::key\+\_\+compare}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_a5175f2a97a1cdf02bdcd65130410d428}\label{class_container_1_1_sequencial_map_a5175f2a97a1cdf02bdcd65130410d428}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!value\_compare@{value\_compare}}
\index{value\_compare@{value\_compare}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{value\_compare}{value\_compare}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::value\+\_\+compare =  typename map\+\_\+type\+::value\+\_\+compare}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}\label{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!value\_type@{value\_type}}
\index{value\_type@{value\_type}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{value\_type}{value\_type}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::value\+\_\+type =  typename map\+\_\+type\+::value\+\_\+type}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_a9f8f9891deaafece7e66b44696a6d37b}\label{class_container_1_1_sequencial_map_a9f8f9891deaafece7e66b44696a6d37b}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!pointer@{pointer}}
\index{pointer@{pointer}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{pointer}{pointer}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::pointer =  typename map\+\_\+type\+::pointer}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_a422ded613b3173982d7b303974f76182}\label{class_container_1_1_sequencial_map_a422ded613b3173982d7b303974f76182}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!const\_pointer@{const\_pointer}}
\index{const\_pointer@{const\_pointer}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{const\_pointer}{const\_pointer}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::const\+\_\+pointer =  typename map\+\_\+type\+::const\+\_\+pointer}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_afff4523f78165d54760940fd9adb616e}\label{class_container_1_1_sequencial_map_afff4523f78165d54760940fd9adb616e}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!reference@{reference}}
\index{reference@{reference}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{reference}{reference}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::reference =  typename map\+\_\+type\+::reference}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}\label{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!const\_reference@{const\_reference}}
\index{const\_reference@{const\_reference}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{const\_reference}{const\_reference}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::const\+\_\+reference =  typename map\+\_\+type\+::const\+\_\+reference}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}\label{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!size\_type@{size\_type}}
\index{size\_type@{size\_type}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{size\_type}{size\_type}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::size\+\_\+type =  typename map\+\_\+type\+::size\+\_\+type}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_a37963b4a5251896ca414b670e1e2175c}\label{class_container_1_1_sequencial_map_a37963b4a5251896ca414b670e1e2175c}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!difference\_type@{difference\_type}}
\index{difference\_type@{difference\_type}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{difference\_type}{difference\_type}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::difference\+\_\+type =  typename map\+\_\+type\+::difference\+\_\+type}



Provide same member type of {\ttfamily std\+::map}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}\label{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!iterator@{iterator}}
\index{iterator@{iterator}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{iterator}{iterator}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::iterator =  \mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1iterator__base}{iterator\+\_\+base}}$<$false$>$}



Mutable iterator type for {\ttfamily Legacy\+Random\+Access\+Iterator}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}\label{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!const\_iterator@{const\_iterator}}
\index{const\_iterator@{const\_iterator}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{const\_iterator}{const\_iterator}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::const\+\_\+iterator =  \mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1iterator__base}{iterator\+\_\+base}}$<$true$>$}



Immutable iterator type for constant {\ttfamily Legacy\+Random\+Access\+Iterator}. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_a030f29381886011469fe1cd6543179ca}\label{class_container_1_1_sequencial_map_a030f29381886011469fe1cd6543179ca}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!reverse\_iterator@{reverse\_iterator}}
\index{reverse\_iterator@{reverse\_iterator}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{reverse\_iterator}{reverse\_iterator}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::reverse\+\_\+iterator =  std\+::reverse\+\_\+iterator$<$\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}$>$}



Mutable reverse iterator type. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}\label{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!const\_reverse\_iterator@{const\_reverse\_iterator}}
\index{const\_reverse\_iterator@{const\_reverse\_iterator}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{const\_reverse\_iterator}{const\_reverse\_iterator}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::const\+\_\+reverse\+\_\+iterator =  std\+::reverse\+\_\+iterator$<$\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}}$>$}



Immutable reverse iterator type. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_a22b824422131d09fe11bb466fec2ca6c}\label{class_container_1_1_sequencial_map_a22b824422131d09fe11bb466fec2ca6c}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!reverse\_key\_iterator@{reverse\_key\_iterator}}
\index{reverse\_key\_iterator@{reverse\_key\_iterator}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{reverse\_key\_iterator}{reverse\_key\_iterator}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
using \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::reverse\+\_\+key\+\_\+iterator =  std\+::reverse\+\_\+iterator$<$\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1key__iterator}{key\+\_\+iterator}}$>$}



Reverse iterator to traverse keys. 



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_a1da133cd9d46c51a2616ec066c825388}\label{class_container_1_1_sequencial_map_a1da133cd9d46c51a2616ec066c825388}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!SequencialMap@{SequencialMap}}
\index{SequencialMap@{SequencialMap}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{SequencialMap()}{SequencialMap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::\+Sequencial\+Map (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Default constructor, constructs an empty container. 

\mbox{\Hypertarget{class_container_1_1_sequencial_map_a2f5a4bf5422199b648d188381399aab5}\label{class_container_1_1_sequencial_map_a2f5a4bf5422199b648d188381399aab5}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!SequencialMap@{SequencialMap}}
\index{SequencialMap@{SequencialMap}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{SequencialMap()}{SequencialMap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::\+Sequencial\+Map (\begin{DoxyParamCaption}\item[{const Compare \&}]{comp,  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructs an empty container with given comparator and allocator. 


\begin{DoxyParams}{Parameters}
{\em comp} & Comparison function object given for this container. \\
\hline
{\em alloc} & Allocator given for this container. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_a82bfbf809ffef3c20d7467c13b1222b6}\label{class_container_1_1_sequencial_map_a82bfbf809ffef3c20d7467c13b1222b6}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!SequencialMap@{SequencialMap}}
\index{SequencialMap@{SequencialMap}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{SequencialMap()}{SequencialMap()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename Input\+It $>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::\+Sequencial\+Map (\begin{DoxyParamCaption}\item[{Input\+It}]{first,  }\item[{Input\+It}]{last,  }\item[{const Compare \&}]{comp = {\ttfamily Compare()},  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs the container with the contents of the range {\ttfamily \mbox{[}first, last)}. If multiple elements in the range have keys that compare equivalent, only the first element is inserted. 


\begin{DoxyParams}{Parameters}
{\em first} & Iterator to the first element to copy from. \\
\hline
{\em last} & Iterator after the last element to copy from. \\
\hline
{\em comp} & Comparison function object given for this container. \\
\hline
{\em alloc} & Allocator given for this container. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_a2aa594ab3466dba8a92357452e060834}\label{class_container_1_1_sequencial_map_a2aa594ab3466dba8a92357452e060834}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!SequencialMap@{SequencialMap}}
\index{SequencialMap@{SequencialMap}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{SequencialMap()}{SequencialMap()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename Input\+It $>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::\+Sequencial\+Map (\begin{DoxyParamCaption}\item[{Input\+It}]{first,  }\item[{Input\+It}]{last,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs the container with the contents of the range {\ttfamily \mbox{[}first, last)}. If multiple elements in the range have keys that compare equivalent, only the first element is inserted. 


\begin{DoxyParams}{Parameters}
{\em first} & Iterator to the first element to copy from. \\
\hline
{\em last} & Iterator after the last element to copy from. \\
\hline
{\em alloc} & Allocator given for this container. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_abb2dad8e14a2caeb3844e47f26ae7dc0}\label{class_container_1_1_sequencial_map_abb2dad8e14a2caeb3844e47f26ae7dc0}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!SequencialMap@{SequencialMap}}
\index{SequencialMap@{SequencialMap}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{SequencialMap()}{SequencialMap()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::\+Sequencial\+Map (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other,  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy constructor. Constructs the container with the copy of the contents of {\ttfamily other}. If {\ttfamily alloc} is not provided, allocator is obtained by calling \`{}\`{}\`{}cpp std\+::allocator\+\_\+traits$<$allocator\+\_\+type$>$\+::select\+\_\+on\+\_\+container\+\_\+copy\+\_\+construction(other.\+get\+\_\+allocator()) \`{}\`{}\`{}. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container to be used as source to initialize the elements of the container with. \\
\hline
{\em alloc} & Allocator given for this container. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_af49228c98db799e81c6fa6b5824db0d8}\label{class_container_1_1_sequencial_map_af49228c98db799e81c6fa6b5824db0d8}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!SequencialMap@{SequencialMap}}
\index{SequencialMap@{SequencialMap}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{SequencialMap()}{SequencialMap()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::\+Sequencial\+Map (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&\&}]{other,  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Move constructor. Constructs the container with the contents of {\ttfamily other} using move semantics. If alloc is not provided, allocator is obtained by move-\/construction from the allocator belonging to {\ttfamily other}. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container to be used as source to initialize the elements of the container with. \\
\hline
{\em alloc} & Allocator given for this container. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_a1c601b369514f03390e87caba773f0a6}\label{class_container_1_1_sequencial_map_a1c601b369514f03390e87caba773f0a6}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!SequencialMap@{SequencialMap}}
\index{SequencialMap@{SequencialMap}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{SequencialMap()}{SequencialMap()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::\+Sequencial\+Map (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} $>$}]{init,  }\item[{const Compare \&}]{comp = {\ttfamily Compare()},  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs the container with the contents of the initializer list {\ttfamily init}. If multiple elements in the range have keys that compare equivalent, only the first element is inserted. 


\begin{DoxyParams}{Parameters}
{\em init} & Initializer list with {\ttfamily value\+\_\+type} elements. \\
\hline
{\em comp} & Comparison function object given for this container. \\
\hline
{\em alloc} & Allocator given for this container. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_abef6363671b5cc82d105b136760e8161}\label{class_container_1_1_sequencial_map_abef6363671b5cc82d105b136760e8161}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!````~SequencialMap@{$\sim$SequencialMap}}
\index{````~SequencialMap@{$\sim$SequencialMap}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$SequencialMap()}{~SequencialMap()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::$\sim$\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-\/to objects are not destroyed. 



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_a3facc9509209b82ef996764e395ce018}\label{class_container_1_1_sequencial_map_a3facc9509209b82ef996764e395ce018}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_a7c95d3b16babee88ec456a8bb1eb7248}{allocator\+\_\+type}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the allocator associated with the container. 

\begin{DoxyReturn}{Returns}
The associated allocator. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_a10b4eadfd412de264780e977b0f88ac1}\label{class_container_1_1_sequencial_map_a10b4eadfd412de264780e977b0f88ac1}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!empty@{empty}}
\index{empty@{empty}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
bool \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Checks if the container has no elements, i.\+e. whether {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef14f6ec882277082f2caf161076979c}{begin()}} == \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if the container is empty, {\ttfamily false} otherwise.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}\label{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!size@{size}}
\index{size@{size}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the number of elements in the container, i.\+e. {\ttfamily std\+::distance(\mbox{\hyperlink{class_container_1_1_sequencial_map_aef14f6ec882277082f2caf161076979c}{begin()}}, \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}})}. 

\begin{DoxyReturn}{Returns}
The number of elements in the container.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a545b66155f26b357fadecec41aef5748}\label{class_container_1_1_sequencial_map_a545b66155f26b357fadecec41aef5748}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!max\_size@{max\_size}}
\index{max\_size@{max\_size}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{max\_size()}{max\_size()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::max\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.\+e. {\ttfamily std\+::distance(\mbox{\hyperlink{class_container_1_1_sequencial_map_aef14f6ec882277082f2caf161076979c}{begin()}}, \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}})} for the largest container. 

\begin{DoxyReturn}{Returns}
Maximum number of elements.
\end{DoxyReturn}
This value typically reflects the theoretical limit on the size of the container, at most {\ttfamily std\+::numeric\+\_\+limits\texorpdfstring{$<$}{<}difference\+\_\+type\texorpdfstring{$>$}{>}::max()}. At runtime, the size of the container may be limited to a value smaller than {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a545b66155f26b357fadecec41aef5748}{max\+\_\+size()}}} by the amount of RAM available.~\newline
 {\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ad2f44dfd27fa008b4b7f2276422b6a13}\label{class_container_1_1_sequencial_map_ad2f44dfd27fa008b4b7f2276422b6a13}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!clear@{clear}}
\index{clear@{clear}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

@brief Erases all elements from the container. After this call, {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}}} returns zero.

Invalidates any references, pointers, or iterators referring to contained elements. Any past-\/the-\/end iterator remains valid.

{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a953b176f0e005d7076cfb790c9f2c1f3}\label{class_container_1_1_sequencial_map_a953b176f0e005d7076cfb790c9f2c1f3}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!contains@{contains}}
\index{contains@{contains}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
bool \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::contains (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Checks if there is an element with key equivalent to key in the container. 


\begin{DoxyParams}{Parameters}
{\em key} & Key value of the element to search for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if there is such an element, otherwise {\ttfamily false}.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a2ed22123549126ebab18333bfe27350a}\label{class_container_1_1_sequencial_map_a2ed22123549126ebab18333bfe27350a}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!find@{find}}
\index{find@{find}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::find (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key equivalent to key. 


\begin{DoxyParams}{Parameters}
{\em key} & Key value of the element to search for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Iterator to an element with key equivalent to {\ttfamily key}. If no such element is found, past-\/the-\/end (see {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}) iterator is returned.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ac2fed678f1ad1cdffc9d5443dc22f340}\label{class_container_1_1_sequencial_map_ac2fed678f1ad1cdffc9d5443dc22f340}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!find@{find}}
\index{find@{find}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::find (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key equivalent to key. 


\begin{DoxyParams}{Parameters}
{\em key} & Key value of the element to search for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Iterator to an element with key equivalent to {\ttfamily key}. If no such element is found, past-\/the-\/end (see {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}) iterator is returned.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_abd3d6d895e0cf5aea8e7cb1be4cbb917}\label{class_container_1_1_sequencial_map_abd3d6d895e0cf5aea8e7cb1be4cbb917}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!keys@{keys}}
\index{keys@{keys}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{keys()}{keys()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename Container  = std\+::vector$<$key\+\_\+type$>$$>$ \\
Container \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::keys (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a list containing all the keys in the map in the sequence order of value appends. 


\begin{DoxyTemplParams}{Template Parameters}
{\em \mbox{\hyperlink{namespace_container}{Container}}} & Vector-\/like container to contain return keys. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
List containing all the keys in the map in the sequence order of value appends.
\end{DoxyReturn}
The order is guaranteed to be the same as that used by {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a9e489cafcef3cbe5b1e1a4a963293283}{values()}}}.

{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_container_1_1_sequencial_map_a9e489cafcef3cbe5b1e1a4a963293283}{values}}, \mbox{\hyperlink{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}{key}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}\label{class_container_1_1_sequencial_map_ace465ea539ffd1ee9effb3382d8dda5e}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!key@{key}}
\index{key@{key}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{key()}{key()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::key (\begin{DoxyParamCaption}\item[{const T \&}]{value,  }\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{default\+Key = {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}}()} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the key with value {\ttfamily value}, or {\ttfamily default\+Key} if the map contains no item with value {\ttfamily value}. 


\begin{DoxyParams}{Parameters}
{\em value} & Value to find key from. \\
\hline
{\em default\+Key} & Default return if the map contains no item with value {\ttfamily value}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The key with value {\ttfamily value}, or {\ttfamily default\+Key} if the map contains no item with value {\ttfamily value}.
\end{DoxyReturn}
This function can be slow(linear time), because its internal data structure is optimized for fast lookup by key, not by value.~\newline
 {\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a9e489cafcef3cbe5b1e1a4a963293283}\label{class_container_1_1_sequencial_map_a9e489cafcef3cbe5b1e1a4a963293283}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!values@{values}}
\index{values@{values}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{values()}{values()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename Container  = std\+::vector$<$\+T$>$$>$ \\
Container \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::values (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a list containing all the values in the map in the sequence order of value appends. 


\begin{DoxyTemplParams}{Template Parameters}
{\em \mbox{\hyperlink{namespace_container}{Container}}} & Vector-\/like container to contain return values. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
List containing all the values in the map in the sequence order of value appends.
\end{DoxyReturn}
The order is guaranteed to be the same as that used by {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a9e489cafcef3cbe5b1e1a4a963293283}{values()}}}.

{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_container_1_1_sequencial_map_abd3d6d895e0cf5aea8e7cb1be4cbb917}{keys}}, \mbox{\hyperlink{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}{value}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}\label{class_container_1_1_sequencial_map_ab2758e11f0139dabdaf0fd38185c1754}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!value@{value}}
\index{value@{value}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{value()}{value()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
const T \& \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::value (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key,  }\item[{const T \&}]{default\+Value = {\ttfamily T()} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the value associated with the key {\ttfamily key}. 


\begin{DoxyParams}{Parameters}
{\em key} & Key to find value from. \\
\hline
{\em default\+Value} & Default return value if the map contains no item with key {\ttfamily key}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The key with value {\ttfamily value}, or {\ttfamily default\+Key} if the map contains no item with value {\ttfamily value}.
\end{DoxyReturn}
If the map contains no item with key {\ttfamily key}, the function returns {\ttfamily default\+Value}.

{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ab4ee6ee6544815e2d0627e3e4c60b445}\label{class_container_1_1_sequencial_map_ab4ee6ee6544815e2d0627e3e4c60b445}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!at@{at}}
\index{at@{at}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{at()}{at()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_afff4523f78165d54760940fd9adb616e}{reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::at (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}}}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reference to the element at specified location {\ttfamily pos}, with bounds checking. 


\begin{DoxyParams}{Parameters}
{\em pos} & Position of the element to return \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference to the requested element. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & If pos is not within the range of the container, i.\+e. {\ttfamily if !(pos \texorpdfstring{$<$}{<} \mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}})}, an exception of type {\ttfamily std\+::out\+\_\+of\+\_\+range} is thrown.\\
\hline
\end{DoxyExceptions}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a6653019c05b42c36dd8233833a77707e}\label{class_container_1_1_sequencial_map_a6653019c05b42c36dd8233833a77707e}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!at@{at}}
\index{at@{at}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{at()}{at()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::at (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}}}]{pos }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a const reference to the element at specified location {\ttfamily pos}, with bounds checking. 


\begin{DoxyParams}{Parameters}
{\em pos} & Position of the element to return \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Const reference to the requested element. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & If pos is not within the range of the container, i.\+e. {\ttfamily if !(pos \texorpdfstring{$<$}{<} \mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}})}, an exception of type {\ttfamily std\+::out\+\_\+of\+\_\+range} is thrown.\\
\hline
\end{DoxyExceptions}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a6f957c4ba9cef3ace6be3677bdade88c}\label{class_container_1_1_sequencial_map_a6f957c4ba9cef3ace6be3677bdade88c}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
T \& \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reference to the value that is mapped to a key equivalent to {\ttfamily key}, performing an insertion if such key does not already exist. 


\begin{DoxyParams}{Parameters}
{\em key} & The key of the element to find. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference to the mapped value of the new element if no element with key {\ttfamily key} existed. Otherwise a reference to the mapped value of the existing element whose key is equivalent to {\ttfamily key}.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a77ffaba89016def1c4548003278dce37}\label{class_container_1_1_sequencial_map_a77ffaba89016def1c4548003278dce37}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
T \& \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\&}]{key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reference to the value that is mapped to a key equivalent to {\ttfamily key}, performing an insertion if such key does not already exist. 


\begin{DoxyParams}{Parameters}
{\em key} & The key of the element to find. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference to the mapped value of the new element if no element with key {\ttfamily key} existed. Otherwise a reference to the mapped value of the existing element whose key is equivalent to {\ttfamily key}.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a96e37928161fded8d073e692c14c8452}\label{class_container_1_1_sequencial_map_a96e37928161fded8d073e692c14c8452}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
const T \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a copy to the value that is mapped to a key equivalent to {\ttfamily key}, return a default constructed value if such key does not already exist. 


\begin{DoxyParams}{Parameters}
{\em key} & The key of the element to find. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Copy to the mapped value of if element with key {\ttfamily key} existed. Otherwise a default constructed value is returned.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a5b9a3adb05dcd295a4fce86a00c042bf}\label{class_container_1_1_sequencial_map_a5b9a3adb05dcd295a4fce86a00c042bf}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
const T \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\&}]{key }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a copy to the value that is mapped to a key equivalent to {\ttfamily key}, return a default constructed value if such key does not already exist. 


\begin{DoxyParams}{Parameters}
{\em key} & The key of the element to find. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Copy to the mapped value of if element with key {\ttfamily key} existed. Otherwise a default constructed value is returned.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a66dfa719b3a57e06e00570ee418709d6}\label{class_container_1_1_sequencial_map_a66dfa719b3a57e06e00570ee418709d6}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!front@{front}}
\index{front@{front}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{front()}{front()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_afff4523f78165d54760940fd9adb616e}{reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::front (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reference to the first element in the container. 

\begin{DoxyReturn}{Returns}
Reference to the first element. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling front on an empty container is undefined.
\end{DoxyWarning}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a1bd8f7e51ccbd91a9eee4dbc19b5027b}\label{class_container_1_1_sequencial_map_a1bd8f7e51ccbd91a9eee4dbc19b5027b}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!front@{front}}
\index{front@{front}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{front()}{front()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::front (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a const reference to the first element in the container. 

\begin{DoxyReturn}{Returns}
Const reference to the first element. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling front on an empty container is undefined.
\end{DoxyWarning}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a167ec50bc2792f6187b56db4b05057a5}\label{class_container_1_1_sequencial_map_a167ec50bc2792f6187b56db4b05057a5}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!back@{back}}
\index{back@{back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{back()}{back()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_afff4523f78165d54760940fd9adb616e}{reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reference to the last element in the container. 

\begin{DoxyReturn}{Returns}
Reference to the last element. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling front on an empty container is undefined.
\end{DoxyWarning}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a8576a0f43e8e0985d53ffb9631b26c73}\label{class_container_1_1_sequencial_map_a8576a0f43e8e0985d53ffb9631b26c73}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!back@{back}}
\index{back@{back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{back()}{back()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a const reference to the last element in the container. 

\begin{DoxyReturn}{Returns}
Const reference to the last element. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling front on an empty container is undefined.
\end{DoxyWarning}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ab9299268be76fe14a653b2239f62a8cf}\label{class_container_1_1_sequencial_map_ab9299268be76fe14a653b2239f62a8cf}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!mid@{mid}}
\index{mid@{mid}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{mid()}{mid()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::mid (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}}}]{pos }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a sub-\/map which contains elements from this map, starting at position {\ttfamily pos} to the end. 


\begin{DoxyParams}{Parameters}
{\em pos} & First element position. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Sub-\/map contains all elements starting from position {\ttfamily pos}.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of the return container, i.\+e., the number of elements starting from {\ttfamily pos}. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a1eeeb3a4862fb9ae342c7402ecda99bf}\label{class_container_1_1_sequencial_map_a1eeeb3a4862fb9ae342c7402ecda99bf}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!mid@{mid}}
\index{mid@{mid}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{mid()}{mid()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::mid (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}}}]{pos,  }\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}}}]{length }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a sub-\/map which contains elements from this map, starting at position {\ttfamily pos}, with {\ttfamily length} elements (or all remaining elements if there are less than {\ttfamily length} elements) are included. 


\begin{DoxyParams}{Parameters}
{\em pos} & First element position. \\
\hline
{\em length} & Elements numbers from {\ttfamily pos} to be included. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Sub-\/map contains {\ttfamily length} elements starting at position {\ttfamily pos}.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of the return container, i.\+e., the number of {\ttfamily length}. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aa9c04c3f3cf92f650884f8db731c955f}\label{class_container_1_1_sequencial_map_aa9c04c3f3cf92f650884f8db731c955f}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}}}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends the given element value to the end of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em value} & The element to append. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a {\ttfamily bool} denoting whether the insertion took place.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a507de063789bd85633eeac5cddd5f23e}\label{class_container_1_1_sequencial_map_a507de063789bd85633eeac5cddd5f23e}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends the given element value to the end of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em value} & The element to append. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a {\ttfamily bool} denoting whether the insertion took place.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aaeab76ed2c5a032d01b19ae85ffef3fd}\label{class_container_1_1_sequencial_map_aaeab76ed2c5a032d01b19ae85ffef3fd}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key,  }\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends the given element value to the end of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em key} & The key of the element to append. \\
\hline
{\em value} & The value of the element to append. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a {\ttfamily bool} denoting whether the insertion took place.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aaac583a4f64517d3a1d5bce90f5824a3}\label{class_container_1_1_sequencial_map_aaac583a4f64517d3a1d5bce90f5824a3}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key,  }\item[{T \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends the given element value to the end of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em key} & The key of the element to append. \\
\hline
{\em value} & The value of the element to append. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a {\ttfamily bool} denoting whether the insertion took place.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aef2b45bd3200f3b6b43679aa3b66cfeb}\label{class_container_1_1_sequencial_map_aef2b45bd3200f3b6b43679aa3b66cfeb}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends all elements from given container {\ttfamily other} to the end of the container, ignores all values with keys already exists in the container. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container to append all elements from.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ae300f91bdfb9d9d84c416377ee62d44a}\label{class_container_1_1_sequencial_map_ae300f91bdfb9d9d84c416377ee62d44a}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} $>$}]{ilist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends all elements from initializer list {\ttfamily ilist} to the end of the container, ignores all values with keys already exists in the container. 


\begin{DoxyParams}{Parameters}
{\em other} & Initializer list to append all elements from.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aa6bb62e84cf18052f75353e7204532b3}\label{class_container_1_1_sequencial_map_aa6bb62e84cf18052f75353e7204532b3}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename Input\+It $>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{Input\+It}]{first,  }\item[{Input\+It}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends all elements from from range {\ttfamily \mbox{[}first, last)} to the end of the container, ignores all values with keys already exists in the container. 


\begin{DoxyParams}{Parameters}
{\em first} & Iterator to the first element to append from. \\
\hline
{\em last} & Iterator after the last element to append from.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert. \mbox{\Hypertarget{class_container_1_1_sequencial_map_af6c31832814c5cc8f213cf07283e20c4}\label{class_container_1_1_sequencial_map_af6c31832814c5cc8f213cf07283e20c4}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!emplace\_back@{emplace\_back}}
\index{emplace\_back@{emplace\_back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_back()}{emplace\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename... Args$>$ \\
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::emplace\+\_\+back (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends a new element to the end of the container. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Args} & Arguments to forward to the constructor of the element. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em key} & The key of the element to append. \\
\hline
{\em args} & Arguments to forward to the constructor of value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a {\ttfamily bool} denoting whether the insertion took place.
\end{DoxyReturn}
The element is constructed through {\ttfamily std\+::allocator\+\_\+traits\+::construct}, which typically uses placement-\/new to construct the element in-\/place at the location provided by the container. The arguments {\ttfamily args...} are forwarded to the constructor as {\ttfamily std\+::forward\texorpdfstring{$<$}{<}Args\texorpdfstring{$>$}{>}(args)...}.~\newline


{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aa2ac071829ff30c8e2d6fee7d9ba0d01}\label{class_container_1_1_sequencial_map_aa2ac071829ff30c8e2d6fee7d9ba0d01}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!emplace\_back@{emplace\_back}}
\index{emplace\_back@{emplace\_back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_back()}{emplace\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename... Args$>$ \\
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::emplace\+\_\+back (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\&}]{key,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends a new element to the end of the container. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Args} & Arguments to forward to the constructor of the element. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em key} & The key of the element to append. \\
\hline
{\em args} & Arguments to forward to the constructor of value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a {\ttfamily bool} denoting whether the insertion took place.
\end{DoxyReturn}
The element is constructed through {\ttfamily std\+::allocator\+\_\+traits\+::construct}, which typically uses placement-\/new to construct the element in-\/place at the location provided by the container. The arguments {\ttfamily args...} are forwarded to the constructor as {\ttfamily std\+::forward\texorpdfstring{$<$}{<}Args\texorpdfstring{$>$}{>}(args)...}.~\newline


{\bfseries{Complexity}}~\newline
 Logarithmic in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a24b3e7e1f562f390b9b98d14e87e3106}\label{class_container_1_1_sequencial_map_a24b3e7e1f562f390b9b98d14e87e3106}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator+@{operator+}}
\index{operator+@{operator+}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator+ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Same as push\+\_\+back, appends all elements from given container {\ttfamily other} to the end of the container, ignores all values with keys already exists in the container. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container to append all elements from.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert. \mbox{\Hypertarget{class_container_1_1_sequencial_map_acdaa1421a064756c48e3f6800a29da6f}\label{class_container_1_1_sequencial_map_acdaa1421a064756c48e3f6800a29da6f}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator+@{operator+}}
\index{operator+@{operator+}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator+ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&\&}]{other }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Same as push\+\_\+back, appends all elements from given container {\ttfamily other} to the end of the container, ignores all values with keys already exists in the container. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container to append all elements from.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aaa688b7dba614eeeefc060c39d7762c5}\label{class_container_1_1_sequencial_map_aaa688b7dba614eeeefc060c39d7762c5}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator+=()}{operator+=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \& \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator+= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Same as push\+\_\+back, appends all elements from given container {\ttfamily other} to the end of the container and return {\ttfamily $\ast$this}, ignores all values with keys already exists in the container. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container to append all elements from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this} after appends.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ab6f6fb831976434f3f0b017acd5dd181}\label{class_container_1_1_sequencial_map_ab6f6fb831976434f3f0b017acd5dd181}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator+=()}{operator+=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \& \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator+= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Same as push\+\_\+back, appends all elements from given container {\ttfamily other} to the end of the container and return {\ttfamily $\ast$this}, ignores all values with keys already exists in the container. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container to append all elements from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this} after appends.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a4589c7bf8eabbe0eea7fde131697d10f}\label{class_container_1_1_sequencial_map_a4589c7bf8eabbe0eea7fde131697d10f}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [1/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pos,  }\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}}}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em pos} & Index to the position before which the new element will be inserted. \\
\hline
{\em value} & Element to insert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator to the inserted element, or to the element that prevented the insertion.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements. \mbox{\Hypertarget{class_container_1_1_sequencial_map_acb0a716f543c72ee5e511cc02f2ba218}\label{class_container_1_1_sequencial_map_acb0a716f543c72ee5e511cc02f2ba218}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [2/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pos,  }\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em pos} & Index to the position before which the new element will be inserted. \\
\hline
{\em value} & Element to insert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator to the inserted element, or to the element that prevented the insertion.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_afe54be787d18ce2faa0857edc118c5c4}\label{class_container_1_1_sequencial_map_afe54be787d18ce2faa0857edc118c5c4}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [3/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pos,  }\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key,  }\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em pos} & Index to the position before which the new element will be inserted. \\
\hline
{\em key} & Key of element to insert. \\
\hline
{\em value} & Value of element to insert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator to the inserted element, or to the element that prevented the insertion.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a325b440c50f6464cc03ddea347b02423}\label{class_container_1_1_sequencial_map_a325b440c50f6464cc03ddea347b02423}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [4/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pos,  }\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key,  }\item[{T \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em pos} & Index to the position before which the new element will be inserted. \\
\hline
{\em key} & Key of element to insert. \\
\hline
{\em value} & Value of element to insert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator to the inserted element, or to the element that prevented the insertion.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a4023b4dfcb55a7b50e0f8f265596835d}\label{class_container_1_1_sequencial_map_a4023b4dfcb55a7b50e0f8f265596835d}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [5/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}}]{pos,  }\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_adaf4af81ffc33e7de86fdbd476845e8c}{const\+\_\+reference}}}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em pos} & Iterator to the position before which the new element will be inserted. \\
\hline
{\em value} & Element to insert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator to the inserted element, or to the element that prevented the insertion.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ae1fb7451d113ac2079426f34853017d8}\label{class_container_1_1_sequencial_map_ae1fb7451d113ac2079426f34853017d8}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [6/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}}]{pos,  }\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em pos} & Iterator to the position before which the new element will be inserted. \\
\hline
{\em value} & Element to insert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator to the inserted element, or to the element that prevented the insertion.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a810c34904f9ec5e27046bc7fab459692}\label{class_container_1_1_sequencial_map_a810c34904f9ec5e27046bc7fab459692}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [7/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}}]{pos,  }\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key,  }\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em pos} & Iterator to the position before which the new element will be inserted. \\
\hline
{\em key} & Key of element to insert. \\
\hline
{\em value} & Value of element to insert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator to the inserted element, or to the element that prevented the insertion.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a814f2c8132f8c84cc82416cc5e4fc68d}\label{class_container_1_1_sequencial_map_a814f2c8132f8c84cc82416cc5e4fc68d}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [8/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}}]{pos,  }\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key,  }\item[{T \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em pos} & Iterator to the position before which the new element will be inserted. \\
\hline
{\em key} & Key of element to insert. \\
\hline
{\em value} & Value of element to insert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator to the inserted element, or to the element that prevented the insertion.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aa3590d08d1b7a66b998a051222eb4db9}\label{class_container_1_1_sequencial_map_aa3590d08d1b7a66b998a051222eb4db9}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [9/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename Input\+It $>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pos,  }\item[{Input\+It}]{first,  }\item[{Input\+It}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Input\+It} & Must meet the requirements of Legacy\+Input\+Iterator. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pos} & Index to the position before which the new element will be inserted. \\
\hline
{\em first} & Iterator to the first element to insert. \\
\hline
{\em last} & Iterator after the last element to insert.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ae1f9d51140e3df712a0ffbcc5372d946}\label{class_container_1_1_sequencial_map_ae1f9d51140e3df712a0ffbcc5372d946}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [10/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pos,  }\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} $>$}]{ilist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em pos} & Index to the position before which the new element will be inserted. \\
\hline
{\em ilist} & Initializer list to insert the values from.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aa1ec0d24659db8cc21a683799486b8f7}\label{class_container_1_1_sequencial_map_aa1ec0d24659db8cc21a683799486b8f7}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [11/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename Input\+It $>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}}]{pos,  }\item[{Input\+It}]{first,  }\item[{Input\+It}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Input\+It} & Must meet the requirements of Legacy\+Input\+Iterator. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pos} & Iterator to the position before which the new element will be inserted. \\
\hline
{\em first} & Iterator to the first element to insert. \\
\hline
{\em last} & Iterator after the last element to insert.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a3f4b3a1ebf98b8ccfccf2ae97a0f8918}\label{class_container_1_1_sequencial_map_a3f4b3a1ebf98b8ccfccf2ae97a0f8918}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!insert@{insert}}
\index{insert@{insert}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [12/12]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}}]{pos,  }\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} $>$}]{ilist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. 


\begin{DoxyParams}{Parameters}
{\em pos} & Iterator to the position before which the new element will be inserted. \\
\hline
{\em ilist} & Initializer list to insert the values from.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(N$\ast$log(\mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + N))}, where N is the number of elements to insert.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a7c6d257953580c6aa2f16e6f249fbb88}\label{class_container_1_1_sequencial_map_a7c6d257953580c6aa2f16e6f249fbb88}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!emplace\_at@{emplace\_at}}
\index{emplace\_at@{emplace\_at}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_at()}{emplace\_at()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename... Args$>$ \\
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::emplace\+\_\+at (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pos,  }\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts a new element to the container as close as possible to the position just before hint. The element is constructed in-\/place, i.\+e. no copy or move operations are performed. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Args} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pos} & Index to the position before which the new element will be inserted. \\
\hline
{\em key} & Key of element to insert. \\
\hline
{\em args} & Arguments to forward to the constructor of the value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns an iterator to the newly inserted element. ~\newline
 If the insertion failed because the element already exists, returns an iterator to the already existing element with the equivalent key.
\end{DoxyReturn}
The constructor of the value type ({\ttfamily T}) is called with exactly the same arguments as supplied to the function, forwarded with {\ttfamily std\+::forward\texorpdfstring{$<$}{<}Args\texorpdfstring{$>$}{>}(args)...}.~\newline
 Invalidates iterators {\bfseries{after}} {\ttfamily pos}.~\newline
 No references are invalidated.

{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ada599a623dfa4ae4edece8633cfc4543}\label{class_container_1_1_sequencial_map_ada599a623dfa4ae4edece8633cfc4543}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!emplace\_at@{emplace\_at}}
\index{emplace\_at@{emplace\_at}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_at()}{emplace\_at()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename... Args$>$ \\
std\+::pair$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}}, bool $>$ \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::emplace\+\_\+at (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pos,  }\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\&}]{key,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts a new element to the container as close as possible to the position just before hint. The element is constructed in-\/place, i.\+e. no copy or move operations are performed. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Args} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pos} & Index to the position before which the new element will be inserted. \\
\hline
{\em key} & Key of element to insert. \\
\hline
{\em args} & Arguments to forward to the constructor of the value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns an iterator to the newly inserted element. ~\newline
 If the insertion failed because the element already exists, returns an iterator to the already existing element with the equivalent key.
\end{DoxyReturn}
The constructor of the value type ({\ttfamily T}) is called with exactly the same arguments as supplied to the function, forwarded with {\ttfamily std\+::forward\texorpdfstring{$<$}{<}Args\texorpdfstring{$>$}{>}(args)...}.~\newline
 Invalidates iterators {\bfseries{after}} {\ttfamily pos}.~\newline
 No references are invalidated.

{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a516e726fdf4060fa02459ba7f2dae636}\label{class_container_1_1_sequencial_map_a516e726fdf4060fa02459ba7f2dae636}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!emplace\_hint@{emplace\_hint}}
\index{emplace\_hint@{emplace\_hint}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_hint()}{emplace\_hint()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename... Args$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::emplace\+\_\+hint (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}}}]{hint,  }\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&\&}]{key,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts a new element to the container as close as possible to the position just before hint. The element is constructed in-\/place, i.\+e. no copy or move operations are performed. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Args} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pos} & Iterator to the position before which the new element will be inserted. \\
\hline
{\em key} & Key of element to insert. \\
\hline
{\em args} & Arguments to forward to the constructor of the value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns an iterator to the newly inserted element. ~\newline
 If the insertion failed because the element already exists, returns an iterator to the already existing element with the equivalent key.
\end{DoxyReturn}
The constructor of the value type ({\ttfamily T}) is called with exactly the same arguments as supplied to the function, forwarded with {\ttfamily std\+::forward\texorpdfstring{$<$}{<}Args\texorpdfstring{$>$}{>}(args)...}.~\newline
 Invalidates iterators {\bfseries{after}} {\ttfamily hint}.~\newline
 No references are invalidated.

{\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a424271f056077ab91d8606eee478d2b1}\label{class_container_1_1_sequencial_map_a424271f056077ab91d8606eee478d2b1}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!pop\_back@{pop\_back}}
\index{pop\_back@{pop\_back}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{pop\_back()}{pop\_back()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::pop\+\_\+back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes the last element of the container. 

Calling pop\+\_\+back on an empty container is undefined.~\newline
 No iterators or references except for \mbox{\hyperlink{class_container_1_1_sequencial_map_a167ec50bc2792f6187b56db4b05057a5}{back()}} and \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}} are invalidated.

{\bfseries{Complexity}}~\newline
 Amortized constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ad090ad2af2de3754b994334c95b0ae4a}\label{class_container_1_1_sequencial_map_ad090ad2af2de3754b994334c95b0ae4a}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!erase@{erase}}
\index{erase@{erase}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::erase (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map_acc67d32902648f64afc2d6e1e315dbeb}{key\+\_\+type}} \&}]{key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes specified element from the container. 


\begin{DoxyParams}{Parameters}
{\em key} & Key of element to erase.\\
\hline
\end{DoxyParams}
Invalidates reference to the erased element.~\newline
 Invalidates iterators at or {\bfseries{after}} the point of the erase.~\newline
 Other references and iterators are not affected.

{\bfseries{Complexity}}~\newline
 Linear\+: the number of calls to the destructor of T is the same as the number of elements erased, the assignment operator of T is called the number of times equal to the number of elements in the vector after the erased elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a03e77d46c8262ea533eb96cd2d096675}\label{class_container_1_1_sequencial_map_a03e77d46c8262ea533eb96cd2d096675}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!erase@{erase}}
\index{erase@{erase}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}}}]{pos,  }\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_ac3543f1423752cb8833894b51791b1f9}{size\+\_\+type}}}]{count = {\ttfamily 1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes specified elements from the container. 


\begin{DoxyParams}{Parameters}
{\em pos} & Index to the position of the first element to erase. \\
\hline
{\em count} & Elements count to erase.\\
\hline
\end{DoxyParams}
Invalidates references to the erased element.~\newline
 Invalidates iterators at or {\bfseries{after}} the eraseed elements.~\newline
 Other references and iterators are not affected.

{\bfseries{Complexity}}~\newline
 Linear\+: the number of calls to the destructor of T is the same as the number of elements erased, the assignment operator of T is called the number of times equal to the number of elements in the vector after the erased elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a42d1128d6f2cceef29f396fe099079e5}\label{class_container_1_1_sequencial_map_a42d1128d6f2cceef29f396fe099079e5}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!erase@{erase}}
\index{erase@{erase}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}}}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes specified elements from the container. 


\begin{DoxyParams}{Parameters}
{\em key} & Key of element to erase. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Iterator following the last removed element. If the iterator pos refers to the last element, the \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}} iterator is returned.
\end{DoxyReturn}
Invalidates reference to the erased element.~\newline
 Invalidates iterators at or {\bfseries{after}} the point of the erase.~\newline
 Other references and iterators are not affected.~\newline


{\bfseries{Complexity}}~\newline
 Linear\+: the number of calls to the destructor of T is the same as the number of elements erased, the assignment operator of T is called the number of times equal to the number of elements in the vector after the erased elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a4d68d6ec7a221315e9eaa97657bfcbb9}\label{class_container_1_1_sequencial_map_a4d68d6ec7a221315e9eaa97657bfcbb9}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!erase@{erase}}
\index{erase@{erase}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}}}]{first,  }\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}}}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes specified elements from the container. 


\begin{DoxyParams}{Parameters}
{\em first} & Iterator to the first element to erase. \\
\hline
{\em last} & Iterator after the last element to erase. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Iterator following the last removed element. If the iterator pos refers to the last element, the \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}} iterator is returned.
\end{DoxyReturn}
Invalidates references to the erased element.~\newline
 Invalidates iterators at or {\bfseries{after}} the eraseed elements.~\newline
 Other references and iterators are not affected.

{\bfseries{Complexity}}~\newline
 Linear\+: the number of calls to the destructor of T is the same as the number of elements erased, the assignment operator of T is called the number of times equal to the number of elements in the vector after the erased elements.~\newline
 Much faster than raw {\ttfamily std\+::vector}, because moved values are {\ttfamily std\+::map\+::iterator}, not acture {\ttfamily T} node. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aef14f6ec882277082f2caf161076979c}\label{class_container_1_1_sequencial_map_aef14f6ec882277082f2caf161076979c}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!begin@{begin}}
\index{begin@{begin}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{begin()}{begin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator to the first element of the container.~\newline
 If the container is empty, the returned iterator will be equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}. 

\begin{DoxyReturn}{Returns}
Iterator to the first element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ac2af7db2d9fda74eb54571529e9796a9}\label{class_container_1_1_sequencial_map_ac2af7db2d9fda74eb54571529e9796a9}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!begin@{begin}}
\index{begin@{begin}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{begin()}{begin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator to the first element of the container.~\newline
 If the container is empty, the returned iterator will be equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}. 

\begin{DoxyReturn}{Returns}
Iterator to the first element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a3592bd4767d34231685cde1571d2ed67}\label{class_container_1_1_sequencial_map_a3592bd4767d34231685cde1571d2ed67}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!cbegin@{cbegin}}
\index{cbegin@{cbegin}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{cbegin()}{cbegin()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::cbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator to the first element of the container.~\newline
 If the container is empty, the returned iterator will be equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}. 

\begin{DoxyReturn}{Returns}
Iterator to the first element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}\label{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!end@{end}}
\index{end@{end}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{end()}{end()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac26b4383280110894eef4f9d9b234cc0}{iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator to the element following the last element of the container.~\newline
 This element acts as a placeholder; attempting to access it results in undefined behavior. 

\begin{DoxyReturn}{Returns}
Iterator to the element following the last element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a1ad471e4549a73f8df09e5a3391611ce}\label{class_container_1_1_sequencial_map_a1ad471e4549a73f8df09e5a3391611ce}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!end@{end}}
\index{end@{end}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{end()}{end()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator to the element following the last element of the container.~\newline
 This element acts as a placeholder; attempting to access it results in undefined behavior. 

\begin{DoxyReturn}{Returns}
Iterator to the element following the last element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_af8361df6d13eb856284108334ac0c48d}\label{class_container_1_1_sequencial_map_af8361df6d13eb856284108334ac0c48d}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!cend@{cend}}
\index{cend@{cend}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{cend()}{cend()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_aa3fdf9c327381f204fedeb6617236028}{const\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::cend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator to the element following the last element of the container.~\newline
 This element acts as a placeholder; attempting to access it results in undefined behavior. 

\begin{DoxyReturn}{Returns}
Iterator to the element following the last element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a4cf6f207f8ab3a88ed385b4f6262c6a7}\label{class_container_1_1_sequencial_map_a4cf6f207f8ab3a88ed385b4f6262c6a7}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!rbegin@{rbegin}}
\index{rbegin@{rbegin}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{rbegin()}{rbegin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_a030f29381886011469fe1cd6543179ca}{reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-\/reversed container. If the container is empty, the returned iterator is equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}{rend()}}}. 

\begin{DoxyReturn}{Returns}
Reverse iterator to the first element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a949f75dea4be0ac64f366585def14b2c}\label{class_container_1_1_sequencial_map_a949f75dea4be0ac64f366585def14b2c}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!rbegin@{rbegin}}
\index{rbegin@{rbegin}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{rbegin()}{rbegin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-\/reversed container. If the container is empty, the returned iterator is equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}{rend()}}}. 

\begin{DoxyReturn}{Returns}
Reverse iterator to the first element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a9de19811bfac99acea78d980ccb51347}\label{class_container_1_1_sequencial_map_a9de19811bfac99acea78d980ccb51347}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!crbegin@{crbegin}}
\index{crbegin@{crbegin}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{crbegin()}{crbegin()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::crbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-\/reversed container. If the container is empty, the returned iterator is equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}{rend()}}}. 

\begin{DoxyReturn}{Returns}
Reverse iterator to the first element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}\label{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!rend@{rend}}
\index{rend@{rend}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{rend()}{rend()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_a030f29381886011469fe1cd6543179ca}{reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-\/reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. 

\begin{DoxyReturn}{Returns}
Reverse iterator to the element following the last element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a0835201ee559bc74afef9984de8c168c}\label{class_container_1_1_sequencial_map_a0835201ee559bc74afef9984de8c168c}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!rend@{rend}}
\index{rend@{rend}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{rend()}{rend()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-\/reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. 

\begin{DoxyReturn}{Returns}
Reverse iterator to the element following the last element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a3781a9637382321983fe00744eb5cf6a}\label{class_container_1_1_sequencial_map_a3781a9637382321983fe00744eb5cf6a}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!crend@{crend}}
\index{crend@{crend}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{crend()}{crend()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ab2d62710a7513d50add4144e908499a3}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::crend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-\/reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. 

\begin{DoxyReturn}{Returns}
Reverse iterator to the element following the last element.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ae56f83636910a5b07f9869b0129cb915}\label{class_container_1_1_sequencial_map_ae56f83636910a5b07f9869b0129cb915}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!key\_begin@{key\_begin}}
\index{key\_begin@{key\_begin}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{key\_begin()}{key\_begin()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1key__iterator}{key\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::key\+\_\+begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator to the first key of the container.~\newline
 If the container is empty, the returned iterator will be equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_aef30d42194b469ad8eebd5ec20253f71}{end()}}}. 

\begin{DoxyReturn}{Returns}
Iterator to the first key.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ac1e3bf5bc5dcbb632ed1948a1cea6ad8}\label{class_container_1_1_sequencial_map_ac1e3bf5bc5dcbb632ed1948a1cea6ad8}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!key\_end@{key\_end}}
\index{key\_end@{key\_end}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{key\_end()}{key\_end()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1key__iterator}{key\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::key\+\_\+end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator to the key following the last key of the container.~\newline
 This key acts as a placeholder; attempting to access it results in undefined behavior. 

\begin{DoxyReturn}{Returns}
Iterator to the key following the last key.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a83a5fc05a8661510d2678dd9af7c2538}\label{class_container_1_1_sequencial_map_a83a5fc05a8661510d2678dd9af7c2538}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!key\_rbegin@{key\_rbegin}}
\index{key\_rbegin@{key\_rbegin}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{key\_rbegin()}{key\_rbegin()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_a22b824422131d09fe11bb466fec2ca6c}{reverse\+\_\+key\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::key\+\_\+rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reverse iterator to the first key of the reversed container. It corresponds to the last key of the non-\/reversed container. If the container is empty, the returned iterator is equal to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a4e8e8ac4302206cddadd9732ef4eb929}{rend()}}}. 

\begin{DoxyReturn}{Returns}
Reverse iterator to the first key.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a8455670da4cc5643d53a0242d86cdd6f}\label{class_container_1_1_sequencial_map_a8455670da4cc5643d53a0242d86cdd6f}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!key\_rend@{key\_rend}}
\index{key\_rend@{key\_rend}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{key\_rend()}{key\_rend()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_a22b824422131d09fe11bb466fec2ca6c}{reverse\+\_\+key\+\_\+iterator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::key\+\_\+rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reverse iterator to the key following the last key of the reversed container. It corresponds to the key preceding the first key of the non-\/reversed container. This key acts as a placeholder, attempting to access it results in undefined behavior. 

\begin{DoxyReturn}{Returns}
Reverse iterator to the key following the last key.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a08b287718cdbd0b455677010229f08b6}\label{class_container_1_1_sequencial_map_a08b287718cdbd0b455677010229f08b6}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator=@{operator=}}
\index{operator=@{operator=}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \& \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replaces the contents of the input container. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container to use as data source \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this}.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of {\ttfamily $\ast$this} and {\ttfamily other}. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a553598ddda9393bb612e96c4f38fce9e}\label{class_container_1_1_sequencial_map_a553598ddda9393bb612e96c4f38fce9e}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator=@{operator=}}
\index{operator=@{operator=}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \& \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replaces the contents of the input container. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container to use as data source \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this}.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Linear in the size of {\ttfamily $\ast$this} unless the allocators do not compare equal and do not propagate, in which case linear in the size of {\ttfamily $\ast$this} and {\ttfamily other}. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a610f956474fc138e8aabc63e81a25773}\label{class_container_1_1_sequencial_map_a610f956474fc138e8aabc63e81a25773}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator=@{operator=}}
\index{operator=@{operator=}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}} \& \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator= (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_container_1_1_sequencial_map_aab11dbc368501e7063836895044e3c6d}{value\+\_\+type}} $>$}]{ilist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replaces the contents of the input container. 


\begin{DoxyParams}{Parameters}
{\em Ilist} & Initializer list to use as data source. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this}.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 {\ttfamily O(\+Nlog\+N)} in general, where {\ttfamily N} is {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a556d6bb956b853cd16edb260a0ed6deb}{size()}} + ilist.\+size()}. Linear if {\ttfamily ilist} is sorted with respect to {\ttfamily \mbox{\hyperlink{class_container_1_1_sequencial_map_a74870be561b4907ac985f21d62419d29}{value\+\_\+comp()}}}. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ae7fd4a84c02afff57265d0c8bd775243}\label{class_container_1_1_sequencial_map_ae7fd4a84c02afff57265d0c8bd775243}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator==@{operator==}}
\index{operator==@{operator==}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator==()}{operator==()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
bool \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator== (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Checks if the contents of two containers are not equal. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container whose contents to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the contents of the containers are {\ttfamily equal}, {\ttfamily false} otherwise.
\end{DoxyReturn}
{\ttfamily Equal} means that they have the same number of elements and each element in {\ttfamily this} compares equal with the element in {\ttfamily other} at the same position.~\newline
 {\bfseries{Complexity}}~\newline
 Constant if containers are of different size, otherwise linear in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_aea0b7cfcab6177efacd4350a2fae1535}\label{class_container_1_1_sequencial_map_aea0b7cfcab6177efacd4350a2fae1535}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator"!=()}{operator!=()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
bool \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator!= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Checks if the contents of two containers are equal, that is,. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container whose contents to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the contents of the containers are {\ttfamily not equal}, {\ttfamily false} otherwise.
\end{DoxyReturn}
{\ttfamily Equal} means that they have the same number of elements and each element in {\ttfamily this} compares equal with the element in {\ttfamily other} at the same position.~\newline
 {\bfseries{Complexity}}~\newline
 Constant if containers are of different size, otherwise linear in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_ad0ddfdc46ecf31066968bdb88a2fb95c}\label{class_container_1_1_sequencial_map_ad0ddfdc46ecf31066968bdb88a2fb95c}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$()}{operator<()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
bool \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator$<$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Compares the contents of two containers lexicographically. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container whose contents to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the contents of {\ttfamily this} are lexicographically {\ttfamily less} than the contents of {\ttfamily other}, {\ttfamily false} otherwise.
\end{DoxyReturn}
The comparison is performed by a function equivalent to {\ttfamily std\+::lexicographical\+\_\+compare}. This comparison ignores the container\textquotesingle{}s ordering Compare.~\newline
 {\bfseries{Complexity}}~\newline
 Linear in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a839e416ce19751824abcdeefc85cdccd}\label{class_container_1_1_sequencial_map_a839e416ce19751824abcdeefc85cdccd}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$=()}{operator<=()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
bool \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator$<$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Compares the contents of two containers lexicographically. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container whose contents to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the contents of {\ttfamily this} are lexicographically {\ttfamily less} than or {\ttfamily equal} the contents of {\ttfamily other}, {\ttfamily false} otherwise.
\end{DoxyReturn}
The comparison is performed by a function equivalent to {\ttfamily std\+::lexicographical\+\_\+compare}. This comparison ignores the container\textquotesingle{}s ordering Compare.~\newline
 {\bfseries{Complexity}}~\newline
 Linear in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a24644885c1fc45f55295def91b435d65}\label{class_container_1_1_sequencial_map_a24644885c1fc45f55295def91b435d65}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator$>$()}{operator>()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
bool \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator$>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Compares the contents of two containers lexicographically. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container whose contents to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the contents of {\ttfamily this} are lexicographically {\ttfamily greater} than the contents of {\ttfamily other}, {\ttfamily false} otherwise.
\end{DoxyReturn}
The comparison is performed by a function equivalent to {\ttfamily std\+::lexicographical\+\_\+compare}. This comparison ignores the container\textquotesingle{}s ordering Compare.~\newline
 {\bfseries{Complexity}}~\newline
 Linear in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a3090d37e36bfef54b9002f36f90f0db9}\label{class_container_1_1_sequencial_map_a3090d37e36bfef54b9002f36f90f0db9}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator$>$=()}{operator>=()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
bool \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::operator$>$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Compares the contents of two containers lexicographically. 


\begin{DoxyParams}{Parameters}
{\em other} & Another container whose contents to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the contents of {\ttfamily this} are lexicographically {\ttfamily greater} than or {\ttfamily equal} the contents of {\ttfamily other}, {\ttfamily false} otherwise.
\end{DoxyReturn}
The comparison is performed by a function equivalent to {\ttfamily std\+::lexicographical\+\_\+compare}. This comparison ignores the container\textquotesingle{}s ordering Compare.~\newline
 {\bfseries{Complexity}}~\newline
 Linear in the size of the container. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a17bf11c644ff3f9f901623a9e00628ab}\label{class_container_1_1_sequencial_map_a17bf11c644ff3f9f901623a9e00628ab}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!swap@{swap}}
\index{swap@{swap}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
void \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. 


\begin{DoxyParams}{Parameters}
{\em other} & \mbox{\hyperlink{namespace_container}{Container}} to exchange the contents with.\\
\hline
\end{DoxyParams}
All iterators and references remain valid. The past-\/the-\/end iterator is invalidated.~\newline
 The Pred objects must be Swappable, and they are exchanged using unqualified call to non-\/member swap.~\newline
 {\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_adccc65fb868b9eb7c2215ba38638e0eb}\label{class_container_1_1_sequencial_map_adccc65fb868b9eb7c2215ba38638e0eb}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!key\_comp@{key\_comp}}
\index{key\_comp@{key\_comp}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{key\_comp()}{key\_comp()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_ac1eed887c3ab20dc88f4351136454566}{key\+\_\+compare}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::key\+\_\+comp (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the function object that compares the keys, which is a copy of this container\textquotesingle{}s constructor argument comp. 

\begin{DoxyReturn}{Returns}
The key comparison function object.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a74870be561b4907ac985f21d62419d29}\label{class_container_1_1_sequencial_map_a74870be561b4907ac985f21d62419d29}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!value\_comp@{value\_comp}}
\index{value\_comp@{value\_comp}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{value\_comp()}{value\_comp()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{class_container_1_1_sequencial_map_a5175f2a97a1cdf02bdcd65130410d428}{value\+\_\+compare}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::value\+\_\+comp (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a function object that compares objects of type {\ttfamily std\+::map\+::value\+\_\+type} (key-\/value pairs) by using {\ttfamily key\+\_\+comp} to compare the first components of the pairs. 

\begin{DoxyReturn}{Returns}
The value comparison function object.
\end{DoxyReturn}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a447011ae320fa1a14c979d18e7848d56}\label{class_container_1_1_sequencial_map_a447011ae320fa1a14c979d18e7848d56}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!serialize@{serialize}}
\index{serialize@{serialize}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{serialize()}{serialize()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1_serialize_manipulator}{Serialize\+Manipulator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::serialize (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Serialize the contents to output stream. 

\begin{DoxyReturn}{Returns}
Serialization manipulator forwarding to output stream.
\end{DoxyReturn}
{\bfseries{Sample Code}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{out << map.serialize();}

\end{DoxyCode}
 \begin{DoxyNote}{Note}
The output stream must support serialization of type {\ttfamily Key} and {\ttfamily T}. 
\end{DoxyNote}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_aecf2617bf43cf5dd18f6f2b5b5e0dc93}\label{class_container_1_1_sequencial_map_aecf2617bf43cf5dd18f6f2b5b5e0dc93}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{deserialize()}{deserialize()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
\mbox{\hyperlink{struct_container_1_1_sequencial_map_1_1_serialize_manipulator}{Serialize\+Manipulator}} \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$\+::deserialize (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deserialize the contents from input stream. 

\begin{DoxyReturn}{Returns}
Deserialization manipulator forwarding to input stream.
\end{DoxyReturn}
{\bfseries{Sample Code}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{in >> map.serialize();}

\end{DoxyCode}
 \begin{DoxyNote}{Note}
The input stream must support deserialization of type {\ttfamily Key} and {\ttfamily T}. 
\end{DoxyNote}


\doxysubsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_a9a3682f82d469079b8257792879f1c60}\label{class_container_1_1_sequencial_map_a9a3682f82d469079b8257792879f1c60}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$}{operator<<}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
template$<$typename Stream $>$ \\
Stream \& operator$<$$<$ (\begin{DoxyParamCaption}\item[{Stream \&}]{out,  }\item[{const \mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Writes the contents of list to output stream. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Stream} & Needs to support streaming type {\ttfamily Key} and {\ttfamily T}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em out} & Output stream. \\
\hline
{\em map} & Map to be written to {\ttfamily out}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Stream\& {\ttfamily out} itself.
\end{DoxyReturn}
Output format will be like\+: \begin{quote}
\mbox{\hyperlink{class_container_1_1_sequencial_map}{Sequencial\+Map}}((\char`\"{}a\char`\"{},0),(\char`\"{}b\char`\"{},1),(\char`\"{}c\char`\"{},2),(\char`\"{}d\char`\"{},3),(\char`\"{}e\char`\"{},4), (\char`\"{}f\char`\"{},5),(\char`\"{}g\char`\"{},6),(\char`\"{}h\char`\"{},7),(\char`\"{}i\char`\"{},8),(\char`\"{}k\char`\"{},9),...) {\bfseries{Complexity}}~\newline
 Linear in the size of the container, i.\+e., the number of elements. \end{quote}
\mbox{\Hypertarget{class_container_1_1_sequencial_map_aa4c0db5a6c160748a0dafee7b258d1bc}\label{class_container_1_1_sequencial_map_aa4c0db5a6c160748a0dafee7b258d1bc}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!swap@{swap}}
\index{swap@{swap}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily template$<$typename Key , typename T , typename Compare  = std\+::less$<$\+Key$>$, typename Allocator  = std\+::allocator$<$std\+::pair$<$const Key, T$>$$>$$>$ \\
void swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{lhs,  }\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Allocator $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Specializes the {\ttfamily std\+::swap} algorithm. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Key} & Key type of input maps. \\
\hline
{\em T} & Value type of input maps. \\
\hline
{\em Compare} & Comparisonf\+Function object to use for all comparisons of keys. \\
\hline
{\em Allocator} & Allocator to use for all memory allocations of this container. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & Map whose contents to swap. \\
\hline
{\em rhs} & Map whose contents to swap.\\
\hline
\end{DoxyParams}
Specializes the {\ttfamily std\+::swap} algorithm for \mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}. Swaps the maps of {\ttfamily lhs} and {\ttfamily rhs}. Calls {\ttfamily lhs.\+swap(rhs)}.

{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_container_1_1_sequencial_map_a35bbbdc21a0b30f8b70df82046c65b66}\label{class_container_1_1_sequencial_map_a35bbbdc21a0b30f8b70df82046c65b66}} 
\index{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}!erase\_if@{erase\_if}}
\index{erase\_if@{erase\_if}!Container::SequencialMap$<$ Key, T, Compare, Allocator $>$@{Container::SequencialMap$<$ Key, T, Compare, Allocator $>$}}
\doxysubsubsection{\texorpdfstring{erase\_if()}{erase\_if()}}
{\footnotesize\ttfamily template$<$class Key , class T , class Compare , class Alloc , class Pred $>$ \\
void erase\+\_\+if (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_container_1_1_sequencial_map}{Container\+::\+Sequencial\+Map}}$<$ Key, T, Compare, Alloc $>$ \&}]{c,  }\item[{Pred}]{pred }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Erases all elements that satisfy the predicate pred from the container. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Key} & Key type of input maps. \\
\hline
{\em T} & Value type of input maps. \\
\hline
{\em Compare} & Comparisonf\+Function object to use for all comparisons of keys. \\
\hline
{\em Alloc} & Allocator to use for all memory allocations of this container. \\
\hline
{\em Pred} & Predicate that returns true if the element should be erased. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em c} & \mbox{\hyperlink{namespace_container}{Container}} from which to erase. \\
\hline
{\em pred} & Predicate that returns true if the element should be erased.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 Constant. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/\+Utilities/\+Containers/\mbox{\hyperlink{_sequencial_map_8hpp}{Sequencial\+Map.\+hpp}}\end{DoxyCompactItemize}
