\hypertarget{class_memory_1_1_safe_shared_ptr}{}\doxysection{Memory\+::Safe\+Shared\+Ptr\texorpdfstring{$<$}{<} T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t \texorpdfstring{$>$}{>} Class Template Reference}
\label{class_memory_1_1_safe_shared_ptr}\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}


Wrapper to {\ttfamily std\+::shared\+\_\+ptr} to provide thread-\/safety while operating the underlying pointer.  




{\ttfamily \#include $<$Safe\+Shared\+Ptr.\+hpp$>$}

\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_array_helper}{Array\+Helper}}
\begin{DoxyCompactList}\small\item\em Proxy class for operator\mbox{[}\mbox{]} in \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}, behave like array element of underlying array object, and provide RAII read-\/write lock for thread safety. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ptr_helper}{Ptr\+Helper}}
\begin{DoxyCompactList}\small\item\em Proxy class for operator-\/\texorpdfstring{$>$}{>} in \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}, behave like underlying object, and provide RAII read-\/write lock for thread safety. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ref_helper}{Ref\+Helper}}
\begin{DoxyCompactList}\small\item\em Proxy class for operator$\ast$ in \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}, behave like underlying object, and provide RAII read-\/write lock for thread safety. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} = mutex\+\_\+t
\begin{DoxyCompactList}\small\item\em Type alias for template shared\+\_\+mutex\+\_\+t. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} = read\+\_\+lock\+\_\+t
\begin{DoxyCompactList}\small\item\em Type alias for template read\+\_\+lock\+\_\+t. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} = write\+\_\+lock\+\_\+t
\begin{DoxyCompactList}\small\item\em Type alias for template write\+\_\+lock\+\_\+t. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a15764a8befe6bc607d64b89282ddf790}{element\+\_\+type}} = typename std\+::remove\+\_\+extent$<$ T $>$\+::type
\begin{DoxyCompactList}\small\item\em Type of element managed. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae41f1af6149b685b27c110b19a65a719}{weak\+\_\+type}} = \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$
\begin{DoxyCompactList}\small\item\em Type of weak pointer from this shared pointer. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
constexpr \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_aeeac6146880f2a94384a786131e0795c}{Safe\+Shared\+Ptr}} ()
\begin{DoxyCompactList}\small\item\em Default constructor, construct a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with no managed object, i.\+e. empty \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}. \end{DoxyCompactList}\item 
constexpr \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a41ad045b71d296d29841970a079e75d3}{Safe\+Shared\+Ptr}} (std\+::nullptr\+\_\+t p)
\begin{DoxyCompactList}\small\item\em Construct a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with no managed object, i.\+e. empty \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a74e811373e69a437ff984fb7b79eca21}{Safe\+Shared\+Ptr}} (Y $\ast$p, typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr)
\begin{DoxyCompactList}\small\item\em Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with a managed object. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a5c50d60f57e20702ba2f2a14abb9e14c}{Safe\+Shared\+Ptr}} (Y $\ast$p, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr)
\begin{DoxyCompactList}\small\item\em Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with a managed object. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y , typename Deleter $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a3ce0660616336054aaa24af283e73f3e}{Safe\+Shared\+Ptr}} (Y $\ast$p, Deleter d, typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr)
\begin{DoxyCompactList}\small\item\em Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with a managed object of specified deleter. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y , typename Deleter $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af217e31f1a81b2904a2763f67b3fccee}{Safe\+Shared\+Ptr}} (Y $\ast$p, Deleter d, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr)
\begin{DoxyCompactList}\small\item\em Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with a managed object of specified deleter. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Deleter $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a664dc347b4b6671ec0da0b9a78144bb2}{Safe\+Shared\+Ptr}} (std\+::nullptr\+\_\+t p, Deleter d)
\begin{DoxyCompactList}\small\item\em Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with with no managed but has specified deleter. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y , typename Deleter , typename Alloc $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_abd267be3c5843ce63b72f96c906484fa}{Safe\+Shared\+Ptr}} (Y $\ast$p, Deleter d, Alloc alloc, typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr)
\begin{DoxyCompactList}\small\item\em Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with a managed object of specified deleter and allocator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y , typename Deleter , typename Alloc $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_aa98fc3faea69b45577952f4fbc44e6d1}{Safe\+Shared\+Ptr}} (Y $\ast$p, Deleter d, Alloc alloc, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr)
\item 
{\footnotesize template$<$typename Deleter , typename Alloc $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_aa7c80a9695eb74a377a0689433cd37f3}{Safe\+Shared\+Ptr}} (std\+::nullptr\+\_\+t p, Deleter d, Alloc alloc)
\begin{DoxyCompactList}\small\item\em Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with no managed but has specified deleter and allocator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y , typename U $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af5926c67fbb7fb28e12366e5e4b0f0fa}{Safe\+Shared\+Ptr}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&other, U $\ast$p) noexcept
\begin{DoxyCompactList}\small\item\em The aliasing constructor\+: constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership information with the initial value of {\ttfamily other}, but holds an unrelated and unmanaged pointer {\ttfamily p}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a28ea811c93c07b4cfe7d71b5c16b1884}{Safe\+Shared\+Ptr}} (const std\+::shared\+\_\+ptr$<$ Y $>$ \&other, T $\ast$p, typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr) noexcept
\begin{DoxyCompactList}\small\item\em The aliasing constructor\+: constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership information with the initial value of {\ttfamily other}, but holds an unrelated and unmanaged pointer {\ttfamily p}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af6e6fb5c4c38bfa0e18b74a3f56473a9}{Safe\+Shared\+Ptr}} (const std\+::shared\+\_\+ptr$<$ Y $>$ \&other, T $\ast$p, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr) noexcept
\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a9147c745c0a087c117652958cca1e07c}{Safe\+Shared\+Ptr}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \&other) noexcept
\begin{DoxyCompactList}\small\item\em Copy constructor, constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership of the object managed by {\ttfamily other}. If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a7fb071a8a3875a93bec00fd737cdce36}{Safe\+Shared\+Ptr}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&other) noexcept
\begin{DoxyCompactList}\small\item\em Copy constructor, constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership of the object managed by {\ttfamily other}. If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ab7d3d0ed9f838f6e930cf8af638360d5}{Safe\+Shared\+Ptr}} (\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em Move constructor, move-\/constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}. After the construction, {\ttfamily $\ast$this} contains a copy of the previous state of {\ttfamily other}, {\ttfamily other} is empty and its stored pointer is null. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af2c6e67aaaad5a8d910311ae6fd995d6}{Safe\+Shared\+Ptr}} (\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em Move constructor, move-\/constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}. After the construction, {\ttfamily $\ast$this} contains a copy of the previous state of {\ttfamily other}, {\ttfamily other} is empty and its stored pointer is null. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ac42fa3ffe7837cbeb1b45fac0d737d6e}{Safe\+Shared\+Ptr}} (const \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&other)
\begin{DoxyCompactList}\small\item\em Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership of the object managed by {\ttfamily other}. If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_aa7bc3e6c98debe915b898678aa2642c2}{Safe\+Shared\+Ptr}} (const std\+::shared\+\_\+ptr$<$ Y $>$ \&other, typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr)
\begin{DoxyCompactList}\small\item\em Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership of the object managed by {\ttfamily other}, and provide read-\/write lock guard for memory safety. If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af568425da383280b7aa6472625a94fe4}{Safe\+Shared\+Ptr}} (const std\+::shared\+\_\+ptr$<$ Y $>$ \&other, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr)
\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a9880ea84ac1475066a737316b8d1b235}{Safe\+Shared\+Ptr}} (std\+::shared\+\_\+ptr$<$ Y $>$ \&\&other, typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr)
\begin{DoxyCompactList}\small\item\em Move-\/constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}. After the construction, {\ttfamily $\ast$this} contains a copy of the previous state of {\ttfamily other}, {\ttfamily other} is empty and its stored pointer is null. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a42aec530388e6d4b492ad3af519392bc}{Safe\+Shared\+Ptr}} (std\+::shared\+\_\+ptr$<$ Y $>$ \&\&other, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$=nullptr)
\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a1c2df83572d82bf2e7c4160401d9ee29}{Safe\+Shared\+Ptr}} (const std\+::weak\+\_\+ptr$<$ Y $>$ \&other)
\begin{DoxyCompactList}\small\item\em Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership of the object managed by {\ttfamily other}. and provide read-\/write lock guard for memory safety. If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ab55e1b406c2678eb7d9795744dfec037}{$\sim$\+Safe\+Shared\+Ptr}} ()=default
\begin{DoxyCompactList}\small\item\em Destructor, destructs the owned object if no more \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} link to it. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a9cb67ead145e8d31d89795ca1d359bdf}{operator=}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \&other) noexcept
\begin{DoxyCompactList}\small\item\em Shares ownership of the object managed by {\ttfamily other}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a53634802cd322f29e76d37d7b681d875}{operator=}} (\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em Move-\/assigns a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a612d5e11edfccf514fc0806927d2f83d}{operator=}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&other) noexcept
\begin{DoxyCompactList}\small\item\em Shares ownership of the object managed by {\ttfamily other}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a9fbf94b94f5c0afc6270b0ab0dcdeffb}{operator=}} (\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em Move-\/assigns a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae27df84a870aa6772502f6a21804ba5d}{operator=}} (const std\+::shared\+\_\+ptr$<$ Y $>$ \&other)
\begin{DoxyCompactList}\small\item\em Shares ownership of the object managed by {\ttfamily other}, and provide read-\/write lock guard for memory safety. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a9da7ee94ff7d22196a85f92e34381a36}{operator=}} (std\+::shared\+\_\+ptr$<$ Y $>$ \&\&other)
\begin{DoxyCompactList}\small\item\em Move-\/assigns a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}, provide read-\/write lock guard for memory safety. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a2793a74e4785e18f3182d6b28388e424}{reset}} ()
\begin{DoxyCompactList}\small\item\em Releases the ownership of the managed object, if any. After the call, {\ttfamily $\ast$this} manages no object. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y $>$ }\\void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ab86f0aee7fa1ea22d904e02bead06b2c}{reset}} (Y $\ast$ptr)
\begin{DoxyCompactList}\small\item\em Replaces the managed object with an object pointed to by ptr. Uses the delete expression as the deleter. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y , typename Deleter $>$ }\\void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ac73b29740bf94575d8d76a1945b8bc1e}{reset}} (Y $\ast$ptr, Deleter d)
\begin{DoxyCompactList}\small\item\em Replaces the managed object with an object pointed to by ptr. Uses the specified deleter {\ttfamily d} as the deleter. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y , typename Deleter , typename Alloc $>$ }\\void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_adf44870440366c44f671b4ea4740d146}{reset}} (Y $\ast$ptr, Deleter d, Alloc alloc)
\begin{DoxyCompactList}\small\item\em Replaces the managed object with an object pointed to by ptr. Uses the specified deleter {\ttfamily d} as the deleter. Uses a copy of alloc for allocation of data for internal use. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a431c7e9ff292cd7a6568152caf497402}{swap}} (\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \&other) noexcept
\begin{DoxyCompactList}\small\item\em Exchanges the contents of {\ttfamily $\ast$this} and {\ttfamily other}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a15764a8befe6bc607d64b89282ddf790}{element\+\_\+type}} $\ast$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the stored pointer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ref_helper}{Ref\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ac390b527de9723be2ad0f2ab89202a3c}{operator$\ast$}} () noexcept
\begin{DoxyCompactList}\small\item\em Dereferences the stored pointer, guard it with {\bfseries{write lock}}. The behavior is undefined if the stored pointer is null. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ref_helper}{Ref\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_acb88efab2e60cdb2541083ce0c5a209b}{operator$\ast$}} () const noexcept
\begin{DoxyCompactList}\small\item\em Dereferences the stored pointer, guard it with {\bfseries{read lock}}. The behavior is undefined if the stored pointer is null. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ptr_helper}{Ptr\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ab508790b00b5e5b0e28e062683837ac2}{operator-\/$>$}} () noexcept
\begin{DoxyCompactList}\small\item\em Dereferences the stored pointer, guard it with {\bfseries{write lock}}. The behavior is undefined if the stored pointer is null. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ptr_helper}{Ptr\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a39ec55d0d90b23e8cb458a10ff9e1931}{operator-\/$>$}} () const noexcept
\begin{DoxyCompactList}\small\item\em Dereferences the stored pointer, guard it with {\bfseries{read lock}}. The behavior is undefined if the stored pointer is null. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_array_helper}{Array\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ac6906c36913884325c58cb7859bdf4c1}{operator\mbox{[}$\,$\mbox{]}}} (std\+::ptrdiff\+\_\+t idx)
\begin{DoxyCompactList}\small\item\em Provides indexed access to the stored array, guard it with {\bfseries{write lock}}. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_array_helper}{Array\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a5fa872abb6970ab4b74a090ffcd5d323}{operator\mbox{[}$\,$\mbox{]}}} (std\+::ptrdiff\+\_\+t idx) const
\begin{DoxyCompactList}\small\item\em Provides indexed access to the stored array, guard it with {\bfseries{read lock}}. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_afcf4f6ff2a313f979b1facc8a133e23d}{use\+\_\+count}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the number of {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} objects referring to the same managed object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4e3e7431c0818afff98ef538eb2603fa}{operator bool}} () const noexcept
\begin{DoxyCompactList}\small\item\em Checks if $\ast$this stores a non-\/null pointer, i.\+e. whether {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}} != nullptr}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y , typename M , typename R , typename W $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_aaf6ba11202dffad645671a4630df231e}{owner\+\_\+before}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, M, R, W $>$ \&other) const
\begin{DoxyCompactList}\small\item\em Checks whether this {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} precedes other in implementation defined owner-\/based (as opposed to value-\/based) order. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Y , typename M , typename R , typename W $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a7734e6c43dabeaec33760869cd2e4b32}{owner\+\_\+before}} (const \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}}$<$ Y, M, R, W $>$ \&other) const
\begin{DoxyCompactList}\small\item\em Checks whether this {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} precedes other in implementation defined owner-\/based (as opposed to value-\/based) order. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}{lock\+\_\+shared}} () const
\begin{DoxyCompactList}\small\item\em Locks the lock for reading. This function will block the current thread if another thread has locked for writing. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}{unlock\+\_\+shared}} () const
\begin{DoxyCompactList}\small\item\em Unlocks the read lock. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock}} ()
\begin{DoxyCompactList}\small\item\em Locks the lock for writing. This function will block the current thread if another thread (including the current) has locked for reading or writing. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}{unlock}} () const
\begin{DoxyCompactList}\small\item\em Unlocks the write lock. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a394e1a8efbcc9ed3023437f99a66f617}{shared\+\_\+lock}} () const
\begin{DoxyCompactList}\small\item\em Generate a RAII guard for read lock, it will call \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}{lock\+\_\+shared()}} on construction and \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}{unlock\+\_\+shared()}} on destruction. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a3abae1cdb34fc682b39d1905c4464afd}{unique\+\_\+lock}} () const
\begin{DoxyCompactList}\small\item\em Generate a RAII guard for write lock, it will call \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock()}} on construction and \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}{unlock()}} on destruction. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Y , typename M , typename R , typename W $>$ }\\class \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a7908794f85e07a5817c7c163bef38aae}{Safe\+Shared\+Ptr}}
\item 
{\footnotesize template$<$typename Y , typename M , typename R , typename W $>$ }\\class \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a42945289d2c9f08fc2105c21e5371aa4}{Safe\+Weak\+Ptr}}
\end{DoxyCompactItemize}
\doxysubsection*{Related Functions}
(Note that these are not member functions.) \begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}  = shared\+\_\+mutex\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}  = shared\+\_\+lock\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}}  = unique\+\_\+lock\+\_\+t, typename... Args$>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_aba373e70b553b08cf7206aa01c860058}{make\+\_\+shared}} (Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Creates a shared pointer that manages a new object. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Alloc , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}  = shared\+\_\+mutex\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}  = shared\+\_\+lock\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}}  = unique\+\_\+lock\+\_\+t, typename... Args$>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a686309b6158b54f593cd09d0a34802b4}{allocate\+\_\+shared}} (const Alloc \&alloc, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Creates a shared pointer that manages a new object allocated using an allocator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename U , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_acfcaa73d9729eac1f4c750c7e784679f}{static\+\_\+pointer\+\_\+cast}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ U, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&r) noexcept
\begin{DoxyCompactList}\small\item\em Applies static\+\_\+cast to the stored pointer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename U , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae64f890d617e6b671b6103d880022b27}{dynamic\+\_\+pointer\+\_\+cast}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ U, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&r) noexcept
\begin{DoxyCompactList}\small\item\em Applies dynamic\+\_\+cast to the stored pointer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename U , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a358fcf2cda62de7df872b1e3e15e8aee}{const\+\_\+pointer\+\_\+cast}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ U, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&r) noexcept
\begin{DoxyCompactList}\small\item\em Applies const\+\_\+cast to the stored pointer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename U , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a393c868824d967df828b4d2b62378497}{reinterpret\+\_\+pointer\+\_\+cast}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ U, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&r) noexcept
\begin{DoxyCompactList}\small\item\em Applies reinterpret\+\_\+cast to the stored pointer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Deleter , typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\Deleter $\ast$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a01dd4bba91bd839c1d9708a2fa1dda30}{get\+\_\+deleter}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&p) noexcept
\begin{DoxyCompactList}\small\item\em Returns the deleter of specified type, if owned. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_aea30536d574f1b543bcaf35093e0f399}{operator==}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a24d831c3866e40edc151ed3886d7323f}{operator!=}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a6b4c984d1deb47c2469cd475ddc25c14}{operator$<$}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a2e10b6b4cfc455208dd9360fb6c00cc6}{operator$>$}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a05af639eed5ce705a12894fdd12c7794}{operator$<$=}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a558f45f4e0d1ca15311415a4915827a9}{operator$>$=}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a6e176a912d85aaa16228c8d3a9ca9795}{operator==}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&lhs, std\+::nullptr\+\_\+t rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a95bb8ef0dc48ecf41fbfc20e03793996}{operator==}} (std\+::nullptr\+\_\+t lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad7eed5d76ff613e8cbbe0d8b09a7687f}{operator!=}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&lhs, std\+::nullptr\+\_\+t rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a699e75e4bdae6b4d249e21cb45958e54}{operator!=}} (std\+::nullptr\+\_\+t lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a5463cddbff946ee0fbf3dac144ef0c6c}{operator$<$}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&lhs, std\+::nullptr\+\_\+t rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ab58cdfbacfa9e2b14f90f9e9f8221467}{operator$<$}} (std\+::nullptr\+\_\+t lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ab80ecfb71eb67881ec5424bd962d8158}{operator$>$}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&lhs, std\+::nullptr\+\_\+t rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a1aba416835ddbdf9b19863ec5019cfb9}{operator$>$}} (std\+::nullptr\+\_\+t lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a26849326620709ff6428b133c79ad1c0}{operator$<$=}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&lhs, std\+::nullptr\+\_\+t rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a193659a1357eb32d3627c72b74b9f9c0}{operator$<$=}} (std\+::nullptr\+\_\+t lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a35960731d11d54985d384f15d7c530e6}{operator$>$=}} (const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&lhs, std\+::nullptr\+\_\+t rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ }\\bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a264f33cced46d07bd154bf3dcaa19725}{operator$>$=}} (std\+::nullptr\+\_\+t lhs, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} , typename OStream $>$ }\\OStream \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a9e2e3789aedc31bd3ffd12d7d82df700}{operator$<$$<$}} (OStream \&os, const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&ptr)
\begin{DoxyCompactList}\small\item\em Outputs the value of the stored pointer to an output stream. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}  = Memory\+::shared\+\_\+mutex\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}  = Memory\+::shared\+\_\+lock\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}}  = Memory\+::unique\+\_\+lock\+\_\+t$>$ }\\void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a6aa42f7da4280c4574b5024a132691d1}{swap}} (\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&lhs, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&rhs) noexcept
\begin{DoxyCompactList}\small\item\em Specializes the {\ttfamily std\+::swap} algorithm. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T, typename mutex\+\_\+t = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t = unique\+\_\+lock\+\_\+t$>$\newline
class Memory\+::\+Safe\+Shared\+Ptr$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$}
Wrapper to {\ttfamily std\+::shared\+\_\+ptr} to provide thread-\/safety while operating the underlying pointer. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of the object managed by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}. \\
\hline
{\em mutex\+\_\+t} & Type of the mutex used, default is shared\+\_\+mutex\+\_\+t. \\
\hline
{\em read\+\_\+lock\+\_\+t} & Type of the read-\/lock used, default is shared\+\_\+lock\+\_\+t. \\
\hline
{\em write\+\_\+lock\+\_\+t} & Type of the write-\/lock used, default is unique\+\_\+lock\+\_\+t.\\
\hline
\end{DoxyTemplParams}
Same API as {\ttfamily std\+::shared\+\_\+ptr}, but operator$\ast$ and operator() are guarded by read-\/write lock to guarantee thread-\/safety.~\newline
 When {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} is a constant object, operations with underlying pointer will be guarded by read lock.~\newline
 When {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} is a mutable object, operations with underlying pointer will be guarded by write lock.~\newline
 ~\newline
 {\bfseries{Sample Code}}~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory::SafeSharedPtr<int>}} ptr = Memory::make\_shared<int>(0);}
\DoxyCodeLine{std::thread thread([](\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory::SafeSharedPtr<int>}} ptr)\{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 1000 * 1000; ++i)}
\DoxyCodeLine{        *ptr += 1;}
\DoxyCodeLine{\}, ptr);}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 1000 * 1000; ++i)}
\DoxyCodeLine{    *ptr += 1;}
\DoxyCodeLine{thread.join();}
\DoxyCodeLine{std::cout << *ptr << std::endl; \textcolor{comment}{// 2000000}}

\end{DoxyCode}
 To prevent lock/unlock too often, call \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}{lock\+\_\+shared()}} / \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock()}}, then use \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}} for raw pointer directly, call \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}{unlock\+\_\+shared()}} / \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}{unlock()}} when finished.~\newline
 ~\newline
 See \href{https://en.cppreference.com/w/cpp/memory/shared_ptr}{\texttt{ https\+://en.\+cppreference.\+com/w/cpp/memory/shared\+\_\+ptr}} for more details of functionalities with std\+::shared\+\_\+ptr.~\newline
 \DoxyHorRuler{0}


{\bfseries{Benchmark on (Intel(\+R) Core(\+R) CPU i5-\/6300U @ 2.\+4\+GHz Turbo 2.\+9\+GHz) 2 cores(4 HTs)}}

Contention Benchmark on integer plus, 90\% read, 10\% write.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Data Type}&\cellcolor{\tableheadbgcolor}\textbf{ Threads}&\cellcolor{\tableheadbgcolor}\textbf{ Iters }&\cellcolor{\tableheadbgcolor}\textbf{ Total t}&\cellcolor{\tableheadbgcolor}\textbf{ t/iter}&\cellcolor{\tableheadbgcolor}\textbf{ iter/sec  }\\\cline{1-6}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Data Type}&\cellcolor{\tableheadbgcolor}\textbf{ Threads}&\cellcolor{\tableheadbgcolor}\textbf{ Iters }&\cellcolor{\tableheadbgcolor}\textbf{ Total t}&\cellcolor{\tableheadbgcolor}\textbf{ t/iter}&\cellcolor{\tableheadbgcolor}\textbf{ iter/sec  }\\\cline{1-6}
\endhead
\multicolumn{6}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ Min\+GW 4.\+8.\+2 32bit on C++11 with \mbox{\hyperlink{class_memory_1_1_r_w_spin_lock}{RWSpin\+Lock}}  }}\\\cline{1-6}
int$\ast$&1&1,000,000 &1.\+59 ms&1.\+59 ns&627 M  \\\cline{1-6}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}&1&1,000,000 &17.\+62 ms&17.\+62 ns&56.\+73 M  \\\cline{1-6}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}&4&1,000,000 &251.\+4 ms&62.\+85 ns&15.\+91 M  \\\cline{1-6}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}&8&1,000,000 &720.\+57 ms&90.\+07 ns&11.\+1 M  \\\cline{1-6}
\multicolumn{6}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ MSVC 2017 64bit (cl 19.\+16.\+27024.\+1) on C++17 with std\+::shared\+\_\+mutex  }}\\\cline{1-6}
int$\ast$&1&1,000,000 &1.\+61 ms&1.\+6 ns&620.\+96 M  \\\cline{1-6}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}&1&1,000,000 &17.\+08 ms&17.\+08 ns&58.\+57 M  \\\cline{1-6}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}&4&1,000,000 &80.\+81 ms&20.\+2 ns&49.\+5 M  \\\cline{1-6}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}&8&1,000,000 &159.\+16 ms&19.\+9 ns&50.\+26 M  \\\cline{1-6}
\end{longtabu}
\begin{DoxyNote}{Note}
{\bfseries{Before C++17}}, for the purposes of the description below, a pointer type {\ttfamily Y$\ast$} requires that {\ttfamily Y$\ast$} must be implicitly convertible to {\ttfamily T$\ast$}.~\newline
 {\bfseries{Since C++17}}, for the purposes of the description below, a pointer type {\ttfamily Y$\ast$} is said to be {\bfseries{compatible}} with a pointer type {\ttfamily T$\ast$} if either {\ttfamily Y$\ast$} is convertible to {\ttfamily T$\ast$} or {\ttfamily Y} is the array type {\ttfamily U\mbox{[}N\mbox{]}} and {\ttfamily T} is {\ttfamily U cv \mbox{[}\mbox{]}} (where cv is some set of cv-\/qualifiers).~\newline
 {\bfseries{Since C++17}}, default deleter called on destructor will use {\ttfamily delete\mbox{[}\mbox{]}} if {\ttfamily T} is an arry type; 
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
Read-\/write lock used in this class is {\bfseries{NOT}} recursive, so {\bfseries{DO NOT}} call {\ttfamily operator.} {\ttfamily operator-\/\texorpdfstring{$>$}{>}} or {\ttfamily operator\mbox{[}\mbox{]}} multiply times in a single line/expression, otherwise a {\bfseries{deadlock}} will happen. Sorry for the inconvenience. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// deadlock happens}}
\DoxyCodeLine{std::cout << point-\/>x() << \textcolor{stringliteral}{"{} "{}} << point-\/>y() << std::endl;}

\end{DoxyCode}

\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}}, \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}} 
\end{DoxySeeAlso}


\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}\label{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SharedMutex@{SharedMutex}}
\index{SharedMutex@{SharedMutex}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SharedMutex}{SharedMutex}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
using \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Shared\+Mutex =  mutex\+\_\+t}



Type alias for template shared\+\_\+mutex\+\_\+t. 

\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}\label{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SharedLock@{SharedLock}}
\index{SharedLock@{SharedLock}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SharedLock}{SharedLock}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
using \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Shared\+Lock =  read\+\_\+lock\+\_\+t}



Type alias for template read\+\_\+lock\+\_\+t. 

\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}\label{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!UniqueLock@{UniqueLock}}
\index{UniqueLock@{UniqueLock}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{UniqueLock}{UniqueLock}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
using \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Unique\+Lock =  write\+\_\+lock\+\_\+t}



Type alias for template write\+\_\+lock\+\_\+t. 

\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a15764a8befe6bc607d64b89282ddf790}\label{class_memory_1_1_safe_shared_ptr_a15764a8befe6bc607d64b89282ddf790}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!element\_type@{element\_type}}
\index{element\_type@{element\_type}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{element\_type}{element\_type}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
using \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::element\+\_\+type =  typename std\+::remove\+\_\+extent$<$T$>$\+::type}



Type of element managed. 

\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ae41f1af6149b685b27c110b19a65a719}\label{class_memory_1_1_safe_shared_ptr_ae41f1af6149b685b27c110b19a65a719}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!weak\_type@{weak\_type}}
\index{weak\_type@{weak\_type}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{weak\_type}{weak\_type}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
using \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::weak\+\_\+type =  \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}}$<$T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}}$>$}



Type of weak pointer from this shared pointer. 



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_aeeac6146880f2a94384a786131e0795c}\label{class_memory_1_1_safe_shared_ptr_aeeac6146880f2a94384a786131e0795c}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [1/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
constexpr \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



Default constructor, construct a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with no managed object, i.\+e. empty \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}. 


\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a41ad045b71d296d29841970a079e75d3}\label{class_memory_1_1_safe_shared_ptr_a41ad045b71d296d29841970a079e75d3}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [2/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
constexpr \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{std\+::nullptr\+\_\+t}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



Construct a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with no managed object, i.\+e. empty \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}. 


\begin{DoxyParams}{Parameters}
{\em p} & nullptr. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a74e811373e69a437ff984fb7b79eca21}\label{class_memory_1_1_safe_shared_ptr_a74e811373e69a437ff984fb7b79eca21}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [3/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{Y $\ast$}]{p,  }\item[{typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with a managed object. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & Pointer to an object to manage. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs.~\newline
 If required additional memory could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete p} (if T is not an array type, {\ttfamily delete\mbox{[}\mbox{]} p} otherwise) (since C++17) is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a5c50d60f57e20702ba2f2a14abb9e14c}\label{class_memory_1_1_safe_shared_ptr_a5c50d60f57e20702ba2f2a14abb9e14c}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [4/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{Y $\ast$}]{p,  }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with a managed object. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & Pointer to an object to manage. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs.~\newline
 If required additional memory could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete p} (if T is not an array type, {\ttfamily delete\mbox{[}\mbox{]} p} otherwise) (since C++17) is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a3ce0660616336054aaa24af283e73f3e}\label{class_memory_1_1_safe_shared_ptr_a3ce0660616336054aaa24af283e73f3e}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [5/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename Deleter $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{Y $\ast$}]{p,  }\item[{Deleter}]{d,  }\item[{typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with a managed object of specified deleter. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
{\em Deleter} & Type of specified deleter. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & Pointer to an object to manage. \\
\hline
{\em d} & Deleter to use to destroy the object, must be {\ttfamily Copy\+Constructible}, and expression d(ptr) must be well formed, have well-\/defined behavior and not throw any exceptions. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs.~\newline
 If required additional memory could not be obtained. May throw implementation-\/defined exception for other errors. d(p) is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_af217e31f1a81b2904a2763f67b3fccee}\label{class_memory_1_1_safe_shared_ptr_af217e31f1a81b2904a2763f67b3fccee}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [6/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename Deleter $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{Y $\ast$}]{p,  }\item[{Deleter}]{d,  }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with a managed object of specified deleter. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
{\em Deleter} & Type of specified deleter. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & Pointer to an object to manage. \\
\hline
{\em d} & Deleter to use to destroy the object, must be {\ttfamily Copy\+Constructible}, and expression d(ptr) must be well formed, have well-\/defined behavior and not throw any exceptions. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs.~\newline
 If required additional memory could not be obtained. May throw implementation-\/defined exception for other errors. d(p) is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a664dc347b4b6671ec0da0b9a78144bb2}\label{class_memory_1_1_safe_shared_ptr_a664dc347b4b6671ec0da0b9a78144bb2}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [7/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Deleter $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{std\+::nullptr\+\_\+t}]{p,  }\item[{Deleter}]{d }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with with no managed but has specified deleter. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Deleter} & Type of specified deleter. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & nullptr. \\
\hline
{\em d} & Deleter to use to destroy the object, must be {\ttfamily Copy\+Constructible}, and expression d(ptr) must be well formed, have well-\/defined behavior and not throw any exceptions. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs.~\newline
 If required additional memory could not be obtained. May throw implementation-\/defined exception for other errors. d(p) is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_abd267be3c5843ce63b72f96c906484fa}\label{class_memory_1_1_safe_shared_ptr_abd267be3c5843ce63b72f96c906484fa}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [8/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename Deleter , typename Alloc $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{Y $\ast$}]{p,  }\item[{Deleter}]{d,  }\item[{Alloc}]{alloc,  }\item[{typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with a managed object of specified deleter and allocator. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
{\em Deleter} & Type of specified deleter. \\
\hline
{\em Alloc} & Type of specified allocator. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & Pointer to an object to manage. \\
\hline
{\em d} & Deleter to use to destroy the object, must be {\ttfamily Copy\+Constructible}, and expression d(ptr) must be well formed, have well-\/defined behavior and not throw any exceptions. \\
\hline
{\em alloc} & Allocator to use for allocations of data for internal use, must satisfy C++ named requirements of {\ttfamily Allocator}. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs.~\newline
 If required additional memory could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily d(p)} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_aa98fc3faea69b45577952f4fbc44e6d1}\label{class_memory_1_1_safe_shared_ptr_aa98fc3faea69b45577952f4fbc44e6d1}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [9/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename Deleter , typename Alloc $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{Y $\ast$}]{p,  }\item[{Deleter}]{d,  }\item[{Alloc}]{alloc,  }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_aa7c80a9695eb74a377a0689433cd37f3}\label{class_memory_1_1_safe_shared_ptr_aa7c80a9695eb74a377a0689433cd37f3}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [10/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Deleter , typename Alloc $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{std\+::nullptr\+\_\+t}]{p,  }\item[{Deleter}]{d,  }\item[{Alloc}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} with no managed but has specified deleter and allocator. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Deleter} & Type of specified deleter. \\
\hline
{\em Alloc} & Type of specified allocator. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & nullptr. \\
\hline
{\em d} & Deleter to use to destroy the object, must be {\ttfamily Copy\+Constructible}, and expression d(ptr) must be well formed, have well-\/defined behavior and not throw any exceptions. \\
\hline
{\em alloc} & Allocator to use for allocations of data for internal use, must satisfy C++ named requirements of {\ttfamily Allocator}. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs.~\newline
 If required additional memory could not be obtained. May throw implementation-\/defined exception for other errors. d(p) is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_af5926c67fbb7fb28e12366e5e4b0f0fa}\label{class_memory_1_1_safe_shared_ptr_af5926c67fbb7fb28e12366e5e4b0f0fa}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [11/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename U $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{other,  }\item[{U $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



The aliasing constructor\+: constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership information with the initial value of {\ttfamily other}, but holds an unrelated and unmanaged pointer {\ttfamily p}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input shared pointer. \\
\hline
{\em U} & Type of input object, U must implicitly convertible to T. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Input {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to share ownership from. \\
\hline
{\em p} & Pointer to an object to manage.\\
\hline
\end{DoxyParams}
If this {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} is the last of the group to go out of scope, it will call the stored deleter for the object originally managed by other. However, calling \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}} on this {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} will always return a copy of {\ttfamily p}. It is the responsibility of the programmer to make sure that this pointer remains valid as long as this {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} exists, such as in the typical use cases where \textquotesingle{}p\textquotesingle{} is a member of the object managed by {\ttfamily other} or is an alias (e.\+g., downcast) of {\ttfamily other.\+get()} after the call. \mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a28ea811c93c07b4cfe7d71b5c16b1884}\label{class_memory_1_1_safe_shared_ptr_a28ea811c93c07b4cfe7d71b5c16b1884}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [12/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{const std\+::shared\+\_\+ptr$<$ Y $>$ \&}]{other,  }\item[{T $\ast$}]{p,  }\item[{typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



The aliasing constructor\+: constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership information with the initial value of {\ttfamily other}, but holds an unrelated and unmanaged pointer {\ttfamily p}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input shared pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Input {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to share ownership from. \\
\hline
{\em p} & Pointer to an object to manage.\\
\hline
\end{DoxyParams}
If this {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} is the last of the group to go out of scope, it will call the stored deleter for the object originally managed by other. However, calling \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}} on this {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} will always return a copy of {\ttfamily p}. It is the responsibility of the programmer to make sure that this pointer remains valid as long as this {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} exists, such as in the typical use cases where \textquotesingle{}p\textquotesingle{} is a member of the object managed by {\ttfamily other} or is an alias (e.\+g., downcast) of {\ttfamily other.\+get()} after the call. \mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_af6e6fb5c4c38bfa0e18b74a3f56473a9}\label{class_memory_1_1_safe_shared_ptr_af6e6fb5c4c38bfa0e18b74a3f56473a9}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [13/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{const std\+::shared\+\_\+ptr$<$ Y $>$ \&}]{other,  }\item[{T $\ast$}]{p,  }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a9147c745c0a087c117652958cca1e07c}\label{class_memory_1_1_safe_shared_ptr_a9147c745c0a087c117652958cca1e07c}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [14/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Copy constructor, constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership of the object managed by {\ttfamily other}. If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too. 


\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to share the ownership from. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a7fb071a8a3875a93bec00fd737cdce36}\label{class_memory_1_1_safe_shared_ptr_a7fb071a8a3875a93bec00fd737cdce36}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [15/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Copy constructor, constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership of the object managed by {\ttfamily other}. If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to share the ownership from. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ab7d3d0ed9f838f6e930cf8af638360d5}\label{class_memory_1_1_safe_shared_ptr_ab7d3d0ed9f838f6e930cf8af638360d5}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [16/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Move constructor, move-\/constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}. After the construction, {\ttfamily $\ast$this} contains a copy of the previous state of {\ttfamily other}, {\ttfamily other} is empty and its stored pointer is null. 


\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to acquire the ownership from. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_af2c6e67aaaad5a8d910311ae6fd995d6}\label{class_memory_1_1_safe_shared_ptr_af2c6e67aaaad5a8d910311ae6fd995d6}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [17/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Move constructor, move-\/constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}. After the construction, {\ttfamily $\ast$this} contains a copy of the previous state of {\ttfamily other}, {\ttfamily other} is empty and its stored pointer is null. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to acquire the ownership from. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ac42fa3ffe7837cbeb1b45fac0d737d6e}\label{class_memory_1_1_safe_shared_ptr_ac42fa3ffe7837cbeb1b45fac0d737d6e}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [18/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership of the object managed by {\ttfamily other}. If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Another weak pointer to share the ownership to. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
{\ttfamily other.\+lock()} may be used for the same purpose\+: the difference is that this constructor throws an exception if the argument is empty, while {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}::\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock()}}} constructs an empty \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} in that case. 
\end{DoxyNote}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+weak\+\_\+ptr} & Throw if {\ttfamily other.\+expired() == true} The constructor has no effect in this case. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_aa7bc3e6c98debe915b898678aa2642c2}\label{class_memory_1_1_safe_shared_ptr_aa7bc3e6c98debe915b898678aa2642c2}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [19/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{const std\+::shared\+\_\+ptr$<$ Y $>$ \&}]{other,  }\item[{typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership of the object managed by {\ttfamily other}, and provide read-\/write lock guard for memory safety. If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Another {\ttfamily std\+::shared} pointer to share the ownership to. \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Only pointer operations with {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} are gauranteed memory safe, operations with existing {\ttfamily std\+::shared\+\_\+ptr} are still without gaurantee. 
\end{DoxyWarning}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_af568425da383280b7aa6472625a94fe4}\label{class_memory_1_1_safe_shared_ptr_af568425da383280b7aa6472625a94fe4}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [20/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{const std\+::shared\+\_\+ptr$<$ Y $>$ \&}]{other,  }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a9880ea84ac1475066a737316b8d1b235}\label{class_memory_1_1_safe_shared_ptr_a9880ea84ac1475066a737316b8d1b235}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [21/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ Y $>$ \&\&}]{other,  }\item[{typename std\+::enable\+\_\+if$<$!std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Move-\/constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}. After the construction, {\ttfamily $\ast$this} contains a copy of the previous state of {\ttfamily other}, {\ttfamily other} is empty and its stored pointer is null. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to acquire the ownership from. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a42aec530388e6d4b492ad3af519392bc}\label{class_memory_1_1_safe_shared_ptr_a42aec530388e6d4b492ad3af519392bc}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [22/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ Y $>$ \&\&}]{other,  }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+base\+\_\+of$<$ \mbox{\hyperlink{class_memory_1_1_enable_safe_shared_from_this}{Enable\+Safe\+Shared\+From\+This}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$, Y $>$\+::value $>$\+::type $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a1c2df83572d82bf2e7c4160401d9ee29}\label{class_memory_1_1_safe_shared_ptr_a1c2df83572d82bf2e7c4160401d9ee29}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr()}{SafeSharedPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [23/23]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::\+Safe\+Shared\+Ptr (\begin{DoxyParamCaption}\item[{const std\+::weak\+\_\+ptr$<$ Y $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} which shares ownership of the object managed by {\ttfamily other}. and provide read-\/write lock guard for memory safety. If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Another weak pointer to share the ownership to. \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Only pointer operations with {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} are gauranteed memory safe, operations with existing {\ttfamily std\+::shared\+\_\+ptr} are still without gaurantee. 
\end{DoxyWarning}
\begin{DoxyNote}{Note}
{\ttfamily other.\+lock()} may be used for the same purpose\+: the difference is that this constructor throws an exception if the argument is empty, while {\ttfamily std\+::weak\+\_\+ptr\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}::\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock()}}} constructs an empty \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} in that case. 
\end{DoxyNote}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+weak\+\_\+ptr} & Throw if {\ttfamily other.\+expired() == true} The constructor has no effect in this case. \\
\hline
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ab55e1b406c2678eb7d9795744dfec037}\label{class_memory_1_1_safe_shared_ptr_ab55e1b406c2678eb7d9795744dfec037}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!````~SafeSharedPtr@{$\sim$SafeSharedPtr}}
\index{````~SafeSharedPtr@{$\sim$SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$SafeSharedPtr()}{~SafeSharedPtr()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::$\sim$\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



Destructor, destructs the owned object if no more \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} link to it. 

If {\ttfamily $\ast$this} owns an object and it is the last {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} owning it, the object is destroyed through the owned deleter. After the destruction, the shared pointers that shared ownership with {\ttfamily $\ast$this}, if any, will report a \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_afcf4f6ff2a313f979b1facc8a133e23d}{use\+\_\+count()}} that is one less than its previous value. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a9cb67ead145e8d31d89795ca1d359bdf}\label{class_memory_1_1_safe_shared_ptr_a9cb67ead145e8d31d89795ca1d359bdf}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator=@{operator=}}
\index{operator=@{operator=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Shares ownership of the object managed by {\ttfamily other}. 


\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to share the ownership to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this} with same object managed by {\ttfamily other}.
\end{DoxyReturn}
Equivalent to {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(other).swap($\ast$this)}.~\newline
 If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too.~\newline
 Replaces the managed object with the one managed by {\ttfamily other}. If $\ast$this already owns an object and it is the last {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} owning it, and {\ttfamily other} is not the same as {\ttfamily $\ast$this}, the object is destroyed through the owned deleter. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a2793a74e4785e18f3182d6b28388e424}{reset}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a53634802cd322f29e76d37d7b681d875}\label{class_memory_1_1_safe_shared_ptr_a53634802cd322f29e76d37d7b681d875}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator=@{operator=}}
\index{operator=@{operator=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Move-\/assigns a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}. 


\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to acquire the ownership from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this} with same object managed by {\ttfamily other}.
\end{DoxyReturn}
Equivalent to {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(std\+::move(other)).swap($\ast$this)}.~\newline
 After the assignment, {\ttfamily $\ast$this} contains a copy of the previous state of {\ttfamily other}, and {\ttfamily other} is empty.~\newline
 Replaces the managed object with the one managed by {\ttfamily other}. If $\ast$this already owns an object and it is the last {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} owning it, and {\ttfamily other} is not the same as {\ttfamily $\ast$this}, the object is destroyed through the owned deleter. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a2793a74e4785e18f3182d6b28388e424}{reset}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a612d5e11edfccf514fc0806927d2f83d}\label{class_memory_1_1_safe_shared_ptr_a612d5e11edfccf514fc0806927d2f83d}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator=@{operator=}}
\index{operator=@{operator=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Shares ownership of the object managed by {\ttfamily other}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to share the ownership to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this} with same object managed by {\ttfamily other}.
\end{DoxyReturn}
Equivalent to {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(other).swap($\ast$this)}.~\newline
 If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too.~\newline
 Replaces the managed object with the one managed by {\ttfamily other}. If $\ast$this already owns an object and it is the last {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} owning it, and {\ttfamily other} is not the same as {\ttfamily $\ast$this}, the object is destroyed through the owned deleter. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a2793a74e4785e18f3182d6b28388e424}{reset}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a9fbf94b94f5c0afc6270b0ab0dcdeffb}\label{class_memory_1_1_safe_shared_ptr_a9fbf94b94f5c0afc6270b0ab0dcdeffb}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator=@{operator=}}
\index{operator=@{operator=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Move-\/assigns a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to acquire the ownership from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this} with same object managed by {\ttfamily other}.
\end{DoxyReturn}
Equivalent to {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(std\+::move(other)).swap($\ast$this)}.~\newline
 After the assignment, {\ttfamily $\ast$this} contains a copy of the previous state of {\ttfamily other}, and {\ttfamily other} is empty.~\newline
 Replaces the managed object with the one managed by {\ttfamily other}. If $\ast$this already owns an object and it is the last {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} owning it, and {\ttfamily other} is not the same as {\ttfamily $\ast$this}, the object is destroyed through the owned deleter. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a2793a74e4785e18f3182d6b28388e424}{reset}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ae27df84a870aa6772502f6a21804ba5d}\label{class_memory_1_1_safe_shared_ptr_ae27df84a870aa6772502f6a21804ba5d}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator=@{operator=}}
\index{operator=@{operator=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator= (\begin{DoxyParamCaption}\item[{const std\+::shared\+\_\+ptr$<$ Y $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Shares ownership of the object managed by {\ttfamily other}, and provide read-\/write lock guard for memory safety. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to share the ownership to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this} with same object managed by {\ttfamily other}.
\end{DoxyReturn}
If {\ttfamily other} manages no object, {\ttfamily $\ast$this} manages no object too.~\newline
 Replaces the managed object with the one managed by {\ttfamily other}. If $\ast$this already owns an object and it is the last {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} owning it, and {\ttfamily other} is not the same as {\ttfamily $\ast$this}, the object is destroyed through the owned deleter. \begin{DoxyWarning}{Warning}
Only pointer operations with {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} are gauranteed memory safe, operations with existing {\ttfamily std\+::shared\+\_\+ptr} are still without gaurantee. 
\end{DoxyWarning}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a2793a74e4785e18f3182d6b28388e424}{reset}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a9da7ee94ff7d22196a85f92e34381a36}\label{class_memory_1_1_safe_shared_ptr_a9da7ee94ff7d22196a85f92e34381a36}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator=@{operator=}}
\index{operator=@{operator=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \& \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator= (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ Y $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Move-\/assigns a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} from {\ttfamily other}, provide read-\/write lock guard for memory safety. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to acquire the ownership from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily $\ast$this} with same object managed by {\ttfamily other}.
\end{DoxyReturn}
After the assignment, {\ttfamily $\ast$this} contains a copy of the previous state of {\ttfamily other}, and {\ttfamily other} is empty.~\newline
 Replaces the managed object with the one managed by {\ttfamily other}. If $\ast$this already owns an object and it is the last {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} owning it, and {\ttfamily other} is not the same as {\ttfamily $\ast$this}, the object is destroyed through the owned deleter. 
\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a2793a74e4785e18f3182d6b28388e424}{reset}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a2793a74e4785e18f3182d6b28388e424}\label{class_memory_1_1_safe_shared_ptr_a2793a74e4785e18f3182d6b28388e424}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!reset@{reset}}
\index{reset@{reset}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Releases the ownership of the managed object, if any. After the call, {\ttfamily $\ast$this} manages no object. 

Equivalent to {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a7908794f85e07a5817c7c163bef38aae}{Safe\+Shared\+Ptr()}}.swap($\ast$this)}.~\newline
 If {\ttfamily $\ast$this} already owns an object and it is the last \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} owning it, the object is destroyed through the owned deleter. 
\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
operator= 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ab86f0aee7fa1ea22d904e02bead06b2c}\label{class_memory_1_1_safe_shared_ptr_ab86f0aee7fa1ea22d904e02bead06b2c}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!reset@{reset}}
\index{reset@{reset}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y $>$ \\
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::reset (\begin{DoxyParamCaption}\item[{Y $\ast$}]{ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replaces the managed object with an object pointed to by ptr. Uses the delete expression as the deleter. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. A valid delete expression must be available, i.\+e. {\ttfamily delete ptr} must be well formed, have well-\/defined behavior and not throw any exceptions. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em ptr} & Pointer to an object to acquire ownership of.\\
\hline
\end{DoxyParams}
Equivalent to {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(ptr).swap($\ast$this)}.~\newline
 Replaces the managed object with an object pointed to by {\ttfamily ptr}. By default, delete expression is used as deleter. Proper delete expression corresponding to the supplied type is always selected, this is the reason why the function is implemented as template using a separate parameter {\ttfamily Y}.~\newline
 If {\ttfamily $\ast$this} already owns an object and it is the last \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} owning it, the object is destroyed through the owned deleter.~\newline
 If the object pointed to by {\ttfamily ptr} is already owned, the function results in undefined behavior. 
\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs.~\newline
 If required additional memory could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete ptr} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
operator= 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ac73b29740bf94575d8d76a1945b8bc1e}\label{class_memory_1_1_safe_shared_ptr_ac73b29740bf94575d8d76a1945b8bc1e}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!reset@{reset}}
\index{reset@{reset}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename Deleter $>$ \\
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::reset (\begin{DoxyParamCaption}\item[{Y $\ast$}]{ptr,  }\item[{Deleter}]{d }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replaces the managed object with an object pointed to by ptr. Uses the specified deleter {\ttfamily d} as the deleter. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
{\em Deleter} & Type of specified deleter. Deleter must be callable for the type {\ttfamily T}, i.\+e. {\ttfamily d(ptr)} must be well formed, have well-\/defined behavior and not throw any exceptions. Deleter must be {\bfseries{Copy\+Constructible}}, and its copy constructor and destructor must not throw exceptions. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em ptr} & Pointer to an object to acquire ownership of. \\
\hline
{\em d} & Deleter to store for deletion of the object.\\
\hline
\end{DoxyParams}
Equivalent to {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(ptr, d).swap($\ast$this)}.~\newline
 Replaces the managed object with an object pointed to by {\ttfamily ptr}. Optional deleter {\ttfamily d} is supplied, which is later used to destroy the new object when no {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} objects own it.~\newline
 If {\ttfamily $\ast$this} already owns an object and it is the last \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} owning it, the object is destroyed through the owned deleter.~\newline
 If the object pointed to by {\ttfamily ptr} is already owned, the function results in undefined behavior. 
\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs.~\newline
 If required additional memory could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily d(ptr)} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
operator= 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_adf44870440366c44f671b4ea4740d146}\label{class_memory_1_1_safe_shared_ptr_adf44870440366c44f671b4ea4740d146}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!reset@{reset}}
\index{reset@{reset}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename Deleter , typename Alloc $>$ \\
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::reset (\begin{DoxyParamCaption}\item[{Y $\ast$}]{ptr,  }\item[{Deleter}]{d,  }\item[{Alloc}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replaces the managed object with an object pointed to by ptr. Uses the specified deleter {\ttfamily d} as the deleter. Uses a copy of alloc for allocation of data for internal use. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of input pointer. \\
\hline
{\em Deleter} & Type of specified deleter. Deleter must be callable for the type {\ttfamily T}, i.\+e. {\ttfamily d(ptr)} must be well formed, have well-\/defined behavior and not throw any exceptions. Deleter must be {\bfseries{Copy\+Constructible}}, and its copy constructor and destructor must not throw exceptions. \\
\hline
{\em Alloc} & Type of specified allocator. Alloc must satisfy C++ named requirements of {\ttfamily Allocator}. The copy constructor and destructor must not throw exceptions. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em ptr} & Pointer to an object to acquire ownership of. \\
\hline
{\em d} & Deleter to store for deletion of the object. \\
\hline
{\em alloc} & Allocator to use for allocations of data for internal use, must satisfy C++ named requirements of {\ttfamily Allocator}.\\
\hline
\end{DoxyParams}
Equivalent to {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(ptr, d, alloc).swap($\ast$this)}.~\newline
 Replaces the managed object with an object pointed to by {\ttfamily ptr}. Optional deleter {\ttfamily d} is supplied, which is later used to destroy the new object when no {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} objects own it.~\newline
 If {\ttfamily $\ast$this} already owns an object and it is the last \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} owning it, the object is destroyed through the owned deleter.~\newline
 If the object pointed to by {\ttfamily ptr} is already owned, the function results in undefined behavior. 
\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & If read-\/write lock could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily delete mutex} is called if an exception occurs.~\newline
 If required additional memory could not be obtained. May throw implementation-\/defined exception for other errors. {\ttfamily d(ptr)} is called if an exception occurs. \\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
operator= 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a431c7e9ff292cd7a6568152caf497402}\label{class_memory_1_1_safe_shared_ptr_a431c7e9ff292cd7a6568152caf497402}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!swap@{swap}}
\index{swap@{swap}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Exchanges the contents of {\ttfamily $\ast$this} and {\ttfamily other}. 


\begin{DoxyParams}{Parameters}
{\em other} & Another shared pointer to exchange the contents with.\\
\hline
\end{DoxyParams}
{\bfseries{Complexity}}~\newline
 Constant. \mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}\label{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!get@{get}}
\index{get@{get}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{get()}{get()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a15764a8befe6bc607d64b89282ddf790}{element\+\_\+type}} $\ast$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::get (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the stored pointer. 

\begin{DoxyReturn}{Returns}
The stored pointer. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
A {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} may share ownership of an object while storing a pointer to another object. {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}} returns the stored pointer, not the managed pointer. 
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
Thread safety is not gauranteed with this method, call \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}{lock\+\_\+shared()}} / \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock()}} before \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}, and call \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}{unlock\+\_\+shared()}} / \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}{unlock()}} when finished. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
operator$\ast$, operator-\/\texorpdfstring{$>$}{>} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ac390b527de9723be2ad0f2ab89202a3c}\label{class_memory_1_1_safe_shared_ptr_ac390b527de9723be2ad0f2ab89202a3c}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ref_helper}{Ref\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator$\ast$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Dereferences the stored pointer, guard it with {\bfseries{write lock}}. The behavior is undefined if the stored pointer is null. 

\begin{DoxyReturn}{Returns}
A temporary object provides proxy to dereferencing the stored pointer, with \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock()}} on construction and \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}{unlock()}} on destruction. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_acb88efab2e60cdb2541083ce0c5a209b}\label{class_memory_1_1_safe_shared_ptr_acb88efab2e60cdb2541083ce0c5a209b}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ref_helper}{Ref\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator$\ast$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Dereferences the stored pointer, guard it with {\bfseries{read lock}}. The behavior is undefined if the stored pointer is null. 

\begin{DoxyReturn}{Returns}
A temporary object provides proxy to dereferencing the stored pointer, with \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}{lock\+\_\+shared()}} on construction and \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}{unlock\+\_\+shared()}} on destruction. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ab508790b00b5e5b0e28e062683837ac2}\label{class_memory_1_1_safe_shared_ptr_ab508790b00b5e5b0e28e062683837ac2}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator-\/$>$@{operator-\/$>$}}
\index{operator-\/$>$@{operator-\/$>$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator-\/$>$()}{operator->()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ptr_helper}{Ptr\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator-\/$>$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Dereferences the stored pointer, guard it with {\bfseries{write lock}}. The behavior is undefined if the stored pointer is null. 

\begin{DoxyReturn}{Returns}
A temporary object provides proxy to the stored pointer, with \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock()}} on construction and \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}{unlock()}} on destruction. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a39ec55d0d90b23e8cb458a10ff9e1931}\label{class_memory_1_1_safe_shared_ptr_a39ec55d0d90b23e8cb458a10ff9e1931}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator-\/$>$@{operator-\/$>$}}
\index{operator-\/$>$@{operator-\/$>$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator-\/$>$()}{operator->()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_ptr_helper}{Ptr\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator-\/$>$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Dereferences the stored pointer, guard it with {\bfseries{read lock}}. The behavior is undefined if the stored pointer is null. 

\begin{DoxyReturn}{Returns}
A temporary object provides proxy to the stored pointer, with \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}{lock\+\_\+shared()}} on construction and \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}{unlock\+\_\+shared()}} on destruction. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ac6906c36913884325c58cb7859bdf4c1}\label{class_memory_1_1_safe_shared_ptr_ac6906c36913884325c58cb7859bdf4c1}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_array_helper}{Array\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{std\+::ptrdiff\+\_\+t}]{idx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Provides indexed access to the stored array, guard it with {\bfseries{write lock}}. 


\begin{DoxyParams}{Parameters}
{\em idx} & The array index. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A temporary object provides proxy to the idx-\/th element of the array, with \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock()}} on construction and \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}{unlock()}} on destruction.
\end{DoxyReturn}
The behavior is undefined if the stored pointer is null or if {\ttfamily idx} is negative.~\newline
 If {\ttfamily T} (the template parameter of \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}) is an array type {\ttfamily U\mbox{[}N\mbox{]}}, {\ttfamily idx} must be less than {\ttfamily N}, otherwise the behavior is undefined.~\newline
 When {\ttfamily T} is not an array type, it is unspecified whether this function is declared. If the function is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal. \begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a5fa872abb6970ab4b74a090ffcd5d323}\label{class_memory_1_1_safe_shared_ptr_a5fa872abb6970ab4b74a090ffcd5d323}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_1_1_array_helper}{Array\+Helper}}$<$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} $>$ \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{std\+::ptrdiff\+\_\+t}]{idx }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Provides indexed access to the stored array, guard it with {\bfseries{read lock}}. 


\begin{DoxyParams}{Parameters}
{\em idx} & The array index. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A temporary object provides proxy to the idx-\/th element of the array, with \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}{lock\+\_\+shared()}} on construction and \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}{unlock\+\_\+shared()}} on destruction.
\end{DoxyReturn}
The behavior is undefined if the stored pointer is null or if {\ttfamily idx} is negative.~\newline
 If {\ttfamily T} (the template parameter of \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}) is an array type {\ttfamily U\mbox{[}N\mbox{]}}, {\ttfamily idx} must be less than {\ttfamily N}, otherwise the behavior is undefined.~\newline
 When {\ttfamily T} is not an array type, it is unspecified whether this function is declared. If the function is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_afcf4f6ff2a313f979b1facc8a133e23d}\label{class_memory_1_1_safe_shared_ptr_afcf4f6ff2a313f979b1facc8a133e23d}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!use\_count@{use\_count}}
\index{use\_count@{use\_count}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{use\_count()}{use\_count()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
long \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::use\+\_\+count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the number of {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} objects referring to the same managed object. 

\begin{DoxyReturn}{Returns}
The number of {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} instances managing the current object or 0 if there is no managed object.
\end{DoxyReturn}
Returns the number of different {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} instances (this included) managing the current object. If there is no managed object, 0 is returned.~\newline
 In multithreaded environment, the value returned by use\+\_\+count is approximate (typical implementations use a {\ttfamily memory\+\_\+order\+\_\+relaxed} load) \begin{DoxyNote}{Note}
Common use cases include\+:~\newline

\begin{DoxyItemize}
\item Comparison with 0. If use\+\_\+count returns zero, the shared pointer is empty and manages no objects (whether or not its stored pointer is null). In multithreaded environment, this does not imply that the destructor of the managed object has completed.
\item Comparison with 1. If use\+\_\+count returns 1, there are no other owners. In multithreaded environment, this does not imply that the object is safe to modify because accesses to the managed object by former shared owners may not have completed, and because new shared owners may be introduced concurrently, such as by \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr_a6566b256f4e2c2bbd84dde1c2acbaf9c}{Safe\+Weak\+Ptr\+::lock}}. 
\end{DoxyItemize}
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a4e3e7431c0818afff98ef538eb2603fa}\label{class_memory_1_1_safe_shared_ptr_a4e3e7431c0818afff98ef538eb2603fa}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator bool@{operator bool}}
\index{operator bool@{operator bool}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator bool()}{operator bool()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::operator bool (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}, {\ttfamily [noexcept]}}



Checks if $\ast$this stores a non-\/null pointer, i.\+e. whether {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}} != nullptr}. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if {\ttfamily $\ast$this} stores a pointer, {\ttfamily false} otherwise. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
An empty {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} (where {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_afcf4f6ff2a313f979b1facc8a133e23d}{use\+\_\+count()}} == 0}) may store a non-\/null pointer accessible by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}, e.\+g. if it were created using the aliasing constructor. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_aaf6ba11202dffad645671a4630df231e}\label{class_memory_1_1_safe_shared_ptr_aaf6ba11202dffad645671a4630df231e}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!owner\_before@{owner\_before}}
\index{owner\_before@{owner\_before}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{owner\_before()}{owner\_before()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename M , typename R , typename W $>$ \\
bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::owner\+\_\+before (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ Y, M, R, W $>$ \&}]{other }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Checks whether this {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} precedes other in implementation defined owner-\/based (as opposed to value-\/based) order. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of the object managed by input pointer. \\
\hline
{\em M} & Type of the mutex used, default is shared\+\_\+mutex\+\_\+t. \\
\hline
{\em R} & Type of the read-\/lock used, default is shared\+\_\+lock\+\_\+t. \\
\hline
{\em W} & Type of the write-\/lock used, default is unique\+\_\+lock\+\_\+t. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & The {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be compared. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if {\ttfamily $\ast$this} precedes other, {\ttfamily false} otherwise. Common implementations compare the addresses of the control blocks.
\end{DoxyReturn}
The order is such that two shared pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}} are different (e.\+g. because they point at different subobjects within the same object) ~\newline
 This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std\+::owner\+\_\+less. \mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a7734e6c43dabeaec33760869cd2e4b32}\label{class_memory_1_1_safe_shared_ptr_a7734e6c43dabeaec33760869cd2e4b32}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!owner\_before@{owner\_before}}
\index{owner\_before@{owner\_before}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{owner\_before()}{owner\_before()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename M , typename R , typename W $>$ \\
bool \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::owner\+\_\+before (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}}$<$ Y, M, R, W $>$ \&}]{other }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Checks whether this {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} precedes other in implementation defined owner-\/based (as opposed to value-\/based) order. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Y} & Type of the object managed by input pointer. \\
\hline
{\em M} & Type of the mutex used, default is shared\+\_\+mutex\+\_\+t. \\
\hline
{\em R} & Type of the read-\/lock used, default is shared\+\_\+lock\+\_\+t. \\
\hline
{\em W} & Type of the write-\/lock used, default is unique\+\_\+lock\+\_\+t. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em other} & the \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}} to be compared. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if {\ttfamily $\ast$this} precedes other, {\ttfamily false} otherwise. Common implementations compare the addresses of the control blocks.
\end{DoxyReturn}
The order is such that two shared pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}} are different (e.\+g. because they point at different subobjects within the same object) ~\newline
 This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std\+::owner\+\_\+less. \mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}\label{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!lock\_shared@{lock\_shared}}
\index{lock\_shared@{lock\_shared}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{lock\_shared()}{lock\_shared()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::lock\+\_\+shared (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Locks the lock for reading. This function will block the current thread if another thread has locked for writing. 

Multiply readers in different thread can lock\+\_\+shared at same time.~\newline
 It is not possible to lock for read if the thread already has locked for write. \begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
Read-\/write lock is {\ttfamily NOT} recursive, locking multiply times in same thread will cause block. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}{unlock\+\_\+shared}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}\label{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!unlock\_shared@{unlock\_shared}}
\index{unlock\_shared@{unlock\_shared}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{unlock\_shared()}{unlock\_shared()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::unlock\+\_\+shared (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Unlocks the read lock. 

Attempting to unlock a lock that is not locked is an error, and will result in undefined behaviour. \begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}{lock\+\_\+shared}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}\label{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!lock@{lock}}
\index{lock@{lock}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{lock()}{lock()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Locks the lock for writing. This function will block the current thread if another thread (including the current) has locked for reading or writing. 

Only {\ttfamily one} write can lock at same time.~\newline
 It is not possible to lock for read if the thread already has locked for write. \begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
Read-\/write lock is {\ttfamily NOT} recursive, locking multiply times in same thread will cause block. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}{unlock}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}\label{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!unlock@{unlock}}
\index{unlock@{unlock}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{unlock()}{unlock()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
void \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::unlock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Unlocks the write lock. 

Attempting to unlock a lock that is not locked is an error, and will result in undefined behaviour. \begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a394e1a8efbcc9ed3023437f99a66f617}\label{class_memory_1_1_safe_shared_ptr_a394e1a8efbcc9ed3023437f99a66f617}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!shared\_lock@{shared\_lock}}
\index{shared\_lock@{shared\_lock}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{shared\_lock()}{shared\_lock()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::shared\+\_\+lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Generate a RAII guard for read lock, it will call \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}{lock\+\_\+shared()}} on construction and \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}{unlock\+\_\+shared()}} on destruction. 

\begin{DoxyReturn}{Returns}
RAII guard for read lock 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a377be554dffd319d515480ea927f9032}{lock\+\_\+shared}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a8323922e0b6137aad2fa13f2c0963e1a}{unlock\+\_\+shared}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a3abae1cdb34fc682b39d1905c4464afd}\label{class_memory_1_1_safe_shared_ptr_a3abae1cdb34fc682b39d1905c4464afd}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!unique\_lock@{unique\_lock}}
\index{unique\_lock@{unique\_lock}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{unique\_lock()}{unique\_lock()}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, mutex\+\_\+t, read\+\_\+lock\+\_\+t, write\+\_\+lock\+\_\+t $>$\+::unique\+\_\+lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Generate a RAII guard for write lock, it will call \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock()}} on construction and \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}{unlock()}} on destruction. 

\begin{DoxyReturn}{Returns}
RAII write for read lock 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This method is thread-\/safe. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4feb9ee085a0ac9b2eeb68ca6e765144}{lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ae37b50a3c53c10e268aed5bc1bf1afac}{unlock}} 
\end{DoxySeeAlso}


\doxysubsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a7908794f85e07a5817c7c163bef38aae}\label{class_memory_1_1_safe_shared_ptr_a7908794f85e07a5817c7c163bef38aae}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeSharedPtr@{SafeSharedPtr}}
\index{SafeSharedPtr@{SafeSharedPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeSharedPtr}{SafeSharedPtr}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename M , typename R , typename W $>$ \\
friend class \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\hspace{0.3cm}{\ttfamily [friend]}}

\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a42945289d2c9f08fc2105c21e5371aa4}\label{class_memory_1_1_safe_shared_ptr_a42945289d2c9f08fc2105c21e5371aa4}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!SafeWeakPtr@{SafeWeakPtr}}
\index{SafeWeakPtr@{SafeWeakPtr}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{SafeWeakPtr}{SafeWeakPtr}}
{\footnotesize\ttfamily template$<$typename T , typename mutex\+\_\+t  = shared\+\_\+mutex\+\_\+t, typename read\+\_\+lock\+\_\+t  = shared\+\_\+lock\+\_\+t, typename write\+\_\+lock\+\_\+t  = unique\+\_\+lock\+\_\+t$>$ \\
template$<$typename Y , typename M , typename R , typename W $>$ \\
friend class \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}}\hspace{0.3cm}{\ttfamily [friend]}}

\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_aba373e70b553b08cf7206aa01c860058}\label{class_memory_1_1_safe_shared_ptr_aba373e70b553b08cf7206aa01c860058}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!make\_shared@{make\_shared}}
\index{make\_shared@{make\_shared}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{make\_shared()}{make\_shared()}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}  = shared\+\_\+mutex\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}  = shared\+\_\+lock\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}}  = unique\+\_\+lock\+\_\+t, typename... Args$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ make\+\_\+shared (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Creates a shared pointer that manages a new object. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of object to be created. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, default is shared\+\_\+mutex\+\_\+t. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, default is shared\+\_\+lock\+\_\+t. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, default is unique\+\_\+lock\+\_\+t. \\
\hline
{\em Args} & Types of arguments in constructor of {\ttfamily T}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em args} & List of arguments with which an instance of {\ttfamily T} will be constructed.\\
\hline
\end{DoxyParams}
Constructs an object of type {\ttfamily T} and wraps it in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} using {\ttfamily args} as the parameter list for the constructor of {\ttfamily T}. The object is constructed as if by the expression {\ttfamily \+::new (pv) T(std\+::forward\texorpdfstring{$<$}{<}Args\texorpdfstring{$>$}{>}(args)...)}, where pv is an internal {\ttfamily void$\ast$} pointer to storage suitable to hold an object of type {\ttfamily T}. The storage is typically larger than {\ttfamily sizeof(\+T)} in order to use one allocation for both the control block of the shared pointer and the {\ttfamily T} object. The {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} constructor called by this function enables \`{}{\ttfamily shared\+\_\+from\+\_\+this} with a pointer to the newly constructed object of type {\ttfamily T}.~\newline
 The object will be destroyed by {\ttfamily p-\/\texorpdfstring{$>$}{>}$\sim$\+X()}, where p is a pointer to the object and {\ttfamily X} is its type. 
\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & May throw std\+::bad\+\_\+alloc or any exception thrown by the constructor of {\ttfamily T}. If an exception is thrown, the functions have no effect. \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
A constructor enables {\ttfamily std\+::enable\+\_\+shared\+\_\+from\+\_\+this} with a pointer ptr of type {\ttfamily U$\ast$} means that it determines if {\ttfamily U} has a base class that is a specialization of {\ttfamily std\+::enable\+\_\+shared\+\_\+from\+\_\+this}, and if so, the constructor evaluates the statement\+:~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{if} (ptr != \textcolor{keyword}{nullptr} \&\& ptr-\/>weak\_this.expired())}
\DoxyCodeLine{  ptr-\/>weak\_this = std::shared\_ptr<std::remove\_cv\_t<U>>(*\textcolor{keyword}{this},}
\DoxyCodeLine{                                   \textcolor{keyword}{const\_cast<}std::remove\_cv\_t<U>*\textcolor{keyword}{>}(ptr));}

\end{DoxyCode}
 Where {\ttfamily weak\+\_\+this} is the hidden mutable {\ttfamily std\+::weak\+\_\+ptr} member of {\ttfamily std\+::shared\+\_\+from\+\_\+this}. The assignment to the {\ttfamily weak\+\_\+this} member is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to {\ttfamily shared\+\_\+from\+\_\+this()} would share ownership with the {\ttfamily shared\+\_\+ptr} created by this raw pointer constructor.~\newline
 The test {\ttfamily ptr-\/\texorpdfstring{$>$}{>}weak\+\_\+this.\+expired()} in the exposition code above makes sure that {\ttfamily weak\+\_\+this} is not reassigned if it already indicates an owner. This test is required as of C++17.~\newline
 ~\newline
 This function may be used as an alternative to {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(new T(args...))}. The trade-\/offs are\+: ~\newline

\begin{DoxyItemize}
\item {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(new T(args...))} performs at least two allocations (one for the object {\ttfamily T} and one for the control block of the shared pointer), while make\+\_\+shared$<$\+T$>$ typically performs only one allocation (the standard recommends, but does not require this, all known implementations do this)~\newline

\item If any \mbox{\hyperlink{class_memory_1_1_safe_weak_ptr}{Safe\+Weak\+Ptr}} references the control block created by make\+\_\+shared after the lifetime of all shared owners ended, the memory occupied by {\ttfamily T} persists until all weak owners get destroyed as well, which may be undesirable if {\ttfamily sizeof(\+T)} is large.
\item {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(new T(args...))} may call a non-\/public constructor of {\ttfamily T} if executed in context where it is accessible, while make\+\_\+shared requires public access to the selected constructor.~\newline

\item Unlike the {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} constructors, make\+\_\+shared does not allow a custom deleter.~\newline

\item make\+\_\+shared uses {\ttfamily \+::new}, so if any special behavior has been set up using a class-\/specific operator new, it will differ from {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(new T(args...))}.~\newline

\end{DoxyItemize}
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a686309b6158b54f593cd09d0a34802b4}{allocate\+\_\+shared}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a686309b6158b54f593cd09d0a34802b4}\label{class_memory_1_1_safe_shared_ptr_a686309b6158b54f593cd09d0a34802b4}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!allocate\_shared@{allocate\_shared}}
\index{allocate\_shared@{allocate\_shared}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{allocate\_shared()}{allocate\_shared()}}
{\footnotesize\ttfamily template$<$typename T , typename Alloc , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}  = shared\+\_\+mutex\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}  = shared\+\_\+lock\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}}  = unique\+\_\+lock\+\_\+t, typename... Args$>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ allocate\+\_\+shared (\begin{DoxyParamCaption}\item[{const Alloc \&}]{alloc,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Creates a shared pointer that manages a new object allocated using an allocator. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of object to be created. \\
\hline
{\em Alloc} & Type of input allocator. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, default is shared\+\_\+mutex\+\_\+t. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, default is shared\+\_\+lock\+\_\+t. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, default is unique\+\_\+lock\+\_\+t. \\
\hline
{\em Args} & Types of arguments in constructor of {\ttfamily T}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em alloc} & The Allocator to use. \\
\hline
{\em args} & List of arguments with which an instance of {\ttfamily T} will be constructed.\\
\hline
\end{DoxyParams}
Constructs an object of type {\ttfamily T} and wraps it in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} using args as the parameter list for the constructor of {\ttfamily T}. The object is constructed as if by the expression {\ttfamily std\+::allocator\+\_\+traits\texorpdfstring{$<$}{<}A2\texorpdfstring{$>$}{>}::construct(a, pv, v)}, where {\ttfamily pv} is an internal {\ttfamily void$\ast$} pointer to storage suitable to hold an object of type {\ttfamily T} and a is a copy of the allocator rebound to {\ttfamily std\+::remove\+\_\+cv\+\_\+t\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}. The storage is typically larger than {\ttfamily sizeof(\+T)} in order to use one allocation for both the control block of the shared pointer and the {\ttfamily T} object. The {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} constructor called by this function enables {\ttfamily shared\+\_\+from\+\_\+this} with a pointer to the newly constructed object of type {\ttfamily T}. All memory allocation is done using a copy of alloc, which must satisfy the Allocator requirements.~\newline
 For allocate\+\_\+shared, the object are destroyed via the expression {\ttfamily std\+::allocator\+\_\+traits\texorpdfstring{$<$}{<}A2\texorpdfstring{$>$}{>}::destroy(a, p)}, where {\ttfamily p} is a pointer to the object and {\ttfamily a} is a copy of the allocator passed to allocate\+\_\+shared, rebound to the type of the object being destroyed. 
\begin{DoxyExceptions}{Exceptions}
{\em User\+Defined} & Can throw the exceptions thrown from {\ttfamily Alloc\+::allocate()} or from the constructor of {\ttfamily T}. If an exception is thrown, this function has no effect. \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
Like make\+\_\+shared, this function typically performs only one allocation, and places both the {\ttfamily T} object and the control block in the allocated memory block (the standard recommends but does not require this, all known implementations do this). A copy of alloc is stored as part of the control block so that it can be used to deallocate it once both shared and weak reference counts reach zero. ~\newline
 Unlike the {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} constructors, allocate\+\_\+shared does not accept a separate custom deleter\+: the supplied allocator is used for destruction of the control block and the {\ttfamily T} object, and for deallocation of their shared memory block.~\newline
 A constructor enables {\ttfamily shared\+\_\+from\+\_\+this} with a pointer ptr of type {\ttfamily U$\ast$} means that it determines if {\ttfamily U} has a base class that is a specialization of {\ttfamily std\+::enable\+\_\+shared\+\_\+from\+\_\+this}, and if so, the constructor evaluates the statement\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{if} (ptr != \textcolor{keyword}{nullptr} \&\& ptr-\/>weak\_this.expired())}
\DoxyCodeLine{  ptr-\/>weak\_this = std::shared\_ptr<std::remove\_cv\_t<U>>(*\textcolor{keyword}{this},}
\DoxyCodeLine{                                   \textcolor{keyword}{const\_cast<}std::remove\_cv\_t<U>*\textcolor{keyword}{>}(ptr));}

\end{DoxyCode}
 Where {\ttfamily weak\+\_\+this} is the hidden mutable {\ttfamily std\+::weak\+\_\+ptr} member of {\ttfamily std\+::shared\+\_\+from\+\_\+this}. The assignment to the {\ttfamily weak\+\_\+this} member is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to {\ttfamily shared\+\_\+from\+\_\+this()} would share ownership with the {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} created by this raw pointer constructor.~\newline
 The test {\ttfamily ptr-\/\texorpdfstring{$>$}{>}weak\+\_\+this.\+expired()} in the exposition code above makes sure that {\ttfamily weak\+\_\+this} is not reassigned if it already indicates an owner. This test is required as of C++17. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_aba373e70b553b08cf7206aa01c860058}{make\+\_\+shared}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_acfcaa73d9729eac1f4c750c7e784679f}\label{class_memory_1_1_safe_shared_ptr_acfcaa73d9729eac1f4c750c7e784679f}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!static\_pointer\_cast@{static\_pointer\_cast}}
\index{static\_pointer\_cast@{static\_pointer\_cast}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{static\_pointer\_cast()}{static\_pointer\_cast()}}
{\footnotesize\ttfamily template$<$typename T , typename U , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ static\+\_\+pointer\+\_\+cast (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ U, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{r }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Applies static\+\_\+cast to the stored pointer. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type to cast to. \\
\hline
{\em U} & Type to cast from. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em r} & The pointer to convert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Safe\+Shared\+Ptr$<$\+T$>$ casted from type {\ttfamily U}.
\end{DoxyReturn}
Creates a new instance of {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} whose stored pointer is obtained from {\ttfamily r}\textquotesingle{}s stored pointer using a cast expression.~\newline
 If {\ttfamily r} is empty, so is the new {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} (but its stored pointer is not necessarily null). Otherwise, the new {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} will share ownership with the initial value of {\ttfamily r}.~\newline
 Let {\ttfamily Y} be {\ttfamily typename std\+::shared\+\_\+ptr\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}::element\+\_\+type}, then the resulting \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\textquotesingle{}s stored pointer will be obtained by evaluating, respectively\+: {\ttfamily static\+\_\+cast\texorpdfstring{$<$}{<}Y$\ast$\texorpdfstring{$>$}{>}(r.\+get())}.~\newline
 The behavior is undefined unless {\ttfamily static\+\_\+cast\texorpdfstring{$<$}{<}T$\ast$\texorpdfstring{$>$}{>}((U$\ast$)nullptr)} is well formed. \begin{DoxyNote}{Note}
The expression {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(static\+\_\+cast\texorpdfstring{$<$}{<}T$\ast$\texorpdfstring{$>$}{>}(r.\+get()))} might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice! 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ae64f890d617e6b671b6103d880022b27}\label{class_memory_1_1_safe_shared_ptr_ae64f890d617e6b671b6103d880022b27}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!dynamic\_pointer\_cast@{dynamic\_pointer\_cast}}
\index{dynamic\_pointer\_cast@{dynamic\_pointer\_cast}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{dynamic\_pointer\_cast()}{dynamic\_pointer\_cast()}}
{\footnotesize\ttfamily template$<$typename T , typename U , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ dynamic\+\_\+pointer\+\_\+cast (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ U, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{r }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Applies dynamic\+\_\+cast to the stored pointer. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type to cast to. \\
\hline
{\em U} & Type to cast from. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em r} & The pointer to convert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Safe\+Shared\+Ptr$<$\+T$>$ casted from type {\ttfamily U}.
\end{DoxyReturn}
Creates a new instance of {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} whose stored pointer is obtained from {\ttfamily r}\textquotesingle{}s stored pointer using a cast expression.~\newline
 If {\ttfamily r} is empty, so is the new {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} (but its stored pointer is not necessarily null). Otherwise, the new {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} will share ownership with the initial value of {\ttfamily r}, except that it is empty if the {\ttfamily dynamic\+\_\+cast} performed by dynamic\+\_\+pointer\+\_\+cast returns a null pointer.~\newline
 Let {\ttfamily Y} be {\ttfamily typename std\+::shared\+\_\+ptr\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}::element\+\_\+type}, then the resulting \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\textquotesingle{}s stored pointer will be obtained by evaluating, respectively\+: {\ttfamily dynamic\+\_\+cast\texorpdfstring{$<$}{<}Y$\ast$\texorpdfstring{$>$}{>}(r.\+get())} (If the result of the {\ttfamily dynamic\+\_\+cast} is a null pointer value, the returned {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} will be empty). The behavior is undefined unless {\ttfamily dynamic\+\_\+cast\texorpdfstring{$<$}{<}T$\ast$\texorpdfstring{$>$}{>}((U$\ast$)nullptr)} is well formed. \begin{DoxyNote}{Note}
The expression {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(dynamic\+\_\+cast\texorpdfstring{$<$}{<}T$\ast$\texorpdfstring{$>$}{>}(r.\+get()))} might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice! 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a358fcf2cda62de7df872b1e3e15e8aee}\label{class_memory_1_1_safe_shared_ptr_a358fcf2cda62de7df872b1e3e15e8aee}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!const\_pointer\_cast@{const\_pointer\_cast}}
\index{const\_pointer\_cast@{const\_pointer\_cast}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{const\_pointer\_cast()}{const\_pointer\_cast()}}
{\footnotesize\ttfamily template$<$typename T , typename U , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ const\+\_\+pointer\+\_\+cast (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ U, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{r }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Applies const\+\_\+cast to the stored pointer. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type to cast to. \\
\hline
{\em U} & Type to cast from. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em r} & The pointer to convert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Safe\+Shared\+Ptr$<$\+T$>$ casted from type {\ttfamily U}.
\end{DoxyReturn}
Creates a new instance of {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} whose stored pointer is obtained from {\ttfamily r}\textquotesingle{}s stored pointer using a cast expression.~\newline
 If {\ttfamily r} is empty, so is the new {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} (but its stored pointer is not necessarily null). Otherwise, the new {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} will share ownership with the initial value of {\ttfamily r}.~\newline
 Let {\ttfamily Y} be {\ttfamily typename std\+::shared\+\_\+ptr\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}::element\+\_\+type}, then the resulting \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\textquotesingle{}s stored pointer will be obtained by evaluating, respectively\+: {\ttfamily const\+\_\+cast\texorpdfstring{$<$}{<}Y$\ast$\texorpdfstring{$>$}{>}(r.\+get())}. The behavior is undefined unless {\ttfamily const\+\_\+cast\texorpdfstring{$<$}{<}T$\ast$\texorpdfstring{$>$}{>}((U$\ast$)nullptr)} is well formed. \begin{DoxyNote}{Note}
The expression {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(const\+\_\+cast\texorpdfstring{$<$}{<}T$\ast$\texorpdfstring{$>$}{>}(r.\+get()))} might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice! 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a393c868824d967df828b4d2b62378497}\label{class_memory_1_1_safe_shared_ptr_a393c868824d967df828b4d2b62378497}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!reinterpret\_pointer\_cast@{reinterpret\_pointer\_cast}}
\index{reinterpret\_pointer\_cast@{reinterpret\_pointer\_cast}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{reinterpret\_pointer\_cast()}{reinterpret\_pointer\_cast()}}
{\footnotesize\ttfamily template$<$typename T , typename U , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ reinterpret\+\_\+pointer\+\_\+cast (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ U, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{r }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Applies reinterpret\+\_\+cast to the stored pointer. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type to cast to. \\
\hline
{\em U} & Type to cast from. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em r} & The pointer to convert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Safe\+Shared\+Ptr$<$\+T$>$ casted from type {\ttfamily U}.
\end{DoxyReturn}
Creates a new instance of {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} whose stored pointer is obtained from {\ttfamily r}\textquotesingle{}s stored pointer using a cast expression.~\newline
 If {\ttfamily r} is empty, so is the new {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} (but its stored pointer is not necessarily null). Otherwise, the new {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} will share ownership with the initial value of {\ttfamily r}.~\newline
 Let {\ttfamily Y} be {\ttfamily typename std\+::shared\+\_\+ptr\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}::element\+\_\+type}, then the resulting \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\textquotesingle{}s stored pointer will be obtained by evaluating, respectively\+: {\ttfamily reinterpret\+\_\+cast\texorpdfstring{$<$}{<}Y$\ast$\texorpdfstring{$>$}{>}(r.\+get())}. The behavior is undefined unless {\ttfamily reinterpret\+\_\+cast\texorpdfstring{$<$}{<}T$\ast$\texorpdfstring{$>$}{>}((U$\ast$)nullptr)} is well formed. \begin{DoxyNote}{Note}
The expression {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(reinterpret\+\_\+cast\texorpdfstring{$<$}{<}T$\ast$\texorpdfstring{$>$}{>}(r.\+get()))} might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice! 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a01dd4bba91bd839c1d9708a2fa1dda30}\label{class_memory_1_1_safe_shared_ptr_a01dd4bba91bd839c1d9708a2fa1dda30}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!get\_deleter@{get\_deleter}}
\index{get\_deleter@{get\_deleter}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{get\_deleter()}{get\_deleter()}}
{\footnotesize\ttfamily template$<$typename Deleter , typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
Deleter $\ast$ get\+\_\+deleter (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Returns the deleter of specified type, if owned. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Deleter} & Type of deleter returned. \\
\hline
{\em T} & Type of the object managed by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & A shared pointer whose deleter needs to be accessed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the owned deleter or {\ttfamily nullptr}. The returned pointer is valid at least as long as there remains at least one \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} instance that owns it.
\end{DoxyReturn}
Access to the {\ttfamily p}\textquotesingle{}s deleter. If the shared pointer {\ttfamily p} owns a deleter of type cv-\/unqualified {\ttfamily Deleter} (e.\+g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer. \begin{DoxyNote}{Note}
The returned pointer may outlive the last {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} if, for example, Safe\+Weak\+Ptrs remain and the implementation doesn\textquotesingle{}t destroy the deleter until the entire control block is destroyed. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_aea30536d574f1b543bcaf35093e0f399}\label{class_memory_1_1_safe_shared_ptr_aea30536d574f1b543bcaf35093e0f399}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator==@{operator==}}
\index{operator==@{operator==}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator==()}{operator==()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ \\
bool operator== (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex\+\_\+L} & Type of lhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
{\em U} & Type of rhs. \\
\hline
{\em Shared\+Mutex\+\_\+R} & Type of rhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily lhs == rhs}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} created using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a24d831c3866e40edc151ed3886d7323f}\label{class_memory_1_1_safe_shared_ptr_a24d831c3866e40edc151ed3886d7323f}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator"!=()}{operator!=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ \\
bool operator!= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex\+\_\+L} & Type of lhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
{\em U} & Type of rhs. \\
\hline
{\em Shared\+Mutex\+\_\+R} & Type of rhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily !(lhs == rhs)}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} created using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a6b4c984d1deb47c2469cd475ddc25c14}\label{class_memory_1_1_safe_shared_ptr_a6b4c984d1deb47c2469cd475ddc25c14}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$()}{operator<()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ \\
bool operator$<$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex\+\_\+L} & Type of lhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
{\em U} & Type of rhs. \\
\hline
{\em Shared\+Mutex\+\_\+R} & Type of rhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily lhs \texorpdfstring{$<$}{<} rhs}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} created using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a2e10b6b4cfc455208dd9360fb6c00cc6}\label{class_memory_1_1_safe_shared_ptr_a2e10b6b4cfc455208dd9360fb6c00cc6}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$>$()}{operator>()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ \\
bool operator$>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex\+\_\+L} & Type of lhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
{\em U} & Type of rhs. \\
\hline
{\em Shared\+Mutex\+\_\+R} & Type of rhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily lhs \texorpdfstring{$>$}{>} rhs}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} created using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a05af639eed5ce705a12894fdd12c7794}\label{class_memory_1_1_safe_shared_ptr_a05af639eed5ce705a12894fdd12c7794}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$=()}{operator<=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ \\
bool operator$<$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex\+\_\+L} & Type of lhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
{\em U} & Type of rhs. \\
\hline
{\em Shared\+Mutex\+\_\+R} & Type of rhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily !(lhs \texorpdfstring{$>$}{>} rhs)}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} created using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a558f45f4e0d1ca15311415a4915827a9}\label{class_memory_1_1_safe_shared_ptr_a558f45f4e0d1ca15311415a4915827a9}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$>$=()}{operator>=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename L , typename Shared\+Mutex\+\_\+L , typename Shared\+Lock\+\_\+L , typename Unique\+Lock\+\_\+L , typename R , typename Shared\+Mutex\+\_\+R , typename Shared\+Lock\+\_\+R , typename Unique\+Lock\+\_\+R $>$ \\
bool operator$>$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ L, Shared\+Mutex\+\_\+L, Shared\+Lock\+\_\+L, Unique\+Lock\+\_\+L $>$ \&}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ R, Shared\+Mutex\+\_\+R, Shared\+Lock\+\_\+R, Unique\+Lock\+\_\+R $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex\+\_\+L} & Type of lhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+L} & Type of lhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
{\em U} & Type of rhs. \\
\hline
{\em Shared\+Mutex\+\_\+R} & Type of rhs\textquotesingle{}s mutex, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s read-\/lock, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock\+\_\+R} & Type of rhs\textquotesingle{}s write-\/lock, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily !(lhs \texorpdfstring{$<$}{<} rhs)}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} created using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a6e176a912d85aaa16228c8d3a9ca9795}\label{class_memory_1_1_safe_shared_ptr_a6e176a912d85aaa16228c8d3a9ca9795}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator==@{operator==}}
\index{operator==@{operator==}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator==()}{operator==()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator== (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{lhs,  }\item[{std\+::nullptr\+\_\+t}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily nullptr} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily lhs == nullptr}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} created using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a95bb8ef0dc48ecf41fbfc20e03793996}\label{class_memory_1_1_safe_shared_ptr_a95bb8ef0dc48ecf41fbfc20e03793996}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator==@{operator==}}
\index{operator==@{operator==}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator==()}{operator==()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator== (\begin{DoxyParamCaption}\item[{std\+::nullptr\+\_\+t}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of rhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily nullptr} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily nullptr == rhs}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} created using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ad7eed5d76ff613e8cbbe0d8b09a7687f}\label{class_memory_1_1_safe_shared_ptr_ad7eed5d76ff613e8cbbe0d8b09a7687f}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator"!=()}{operator!=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator!= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{lhs,  }\item[{std\+::nullptr\+\_\+t}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily nullptr} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily !(lhs == nullptr)}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} created using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a699e75e4bdae6b4d249e21cb45958e54}\label{class_memory_1_1_safe_shared_ptr_a699e75e4bdae6b4d249e21cb45958e54}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator"!=()}{operator!=()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator!= (\begin{DoxyParamCaption}\item[{std\+::nullptr\+\_\+t}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of rhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily nullptr} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily !(nullptr == rhs)}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} created using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a5463cddbff946ee0fbf3dac144ef0c6c}\label{class_memory_1_1_safe_shared_ptr_a5463cddbff946ee0fbf3dac144ef0c6c}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$()}{operator<()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator$<$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{lhs,  }\item[{std\+::nullptr\+\_\+t}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily nullptr} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily lhs \texorpdfstring{$<$}{<} nullptr}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a Safe\+Shared\+Ptrcreated using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ab58cdfbacfa9e2b14f90f9e9f8221467}\label{class_memory_1_1_safe_shared_ptr_ab58cdfbacfa9e2b14f90f9e9f8221467}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$()}{operator<()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator$<$ (\begin{DoxyParamCaption}\item[{std\+::nullptr\+\_\+t}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of rhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily nullptr} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily nullptr \texorpdfstring{$<$}{<} rhs}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a Safe\+Shared\+Ptrcreated using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_ab80ecfb71eb67881ec5424bd962d8158}\label{class_memory_1_1_safe_shared_ptr_ab80ecfb71eb67881ec5424bd962d8158}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$>$()}{operator>()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator$>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{lhs,  }\item[{std\+::nullptr\+\_\+t}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily nullptr} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily lhs \texorpdfstring{$>$}{>} nullptr}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a Safe\+Shared\+Ptrcreated using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a1aba416835ddbdf9b19863ec5019cfb9}\label{class_memory_1_1_safe_shared_ptr_a1aba416835ddbdf9b19863ec5019cfb9}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$>$()}{operator>()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator$>$ (\begin{DoxyParamCaption}\item[{std\+::nullptr\+\_\+t}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of rhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily nullptr} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily nullptr \texorpdfstring{$>$}{>} rhs}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a Safe\+Shared\+Ptrcreated using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a26849326620709ff6428b133c79ad1c0}\label{class_memory_1_1_safe_shared_ptr_a26849326620709ff6428b133c79ad1c0}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$=()}{operator<=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator$<$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{lhs,  }\item[{std\+::nullptr\+\_\+t}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily nullptr} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily !(lhs \texorpdfstring{$>$}{>} nullptr)}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a Safe\+Shared\+Ptrcreated using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a193659a1357eb32d3627c72b74b9f9c0}\label{class_memory_1_1_safe_shared_ptr_a193659a1357eb32d3627c72b74b9f9c0}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$=()}{operator<=()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator$<$= (\begin{DoxyParamCaption}\item[{std\+::nullptr\+\_\+t}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of rhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily nullptr} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily !(nullptr \texorpdfstring{$>$}{>} rhs)}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a Safe\+Shared\+Ptrcreated using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a35960731d11d54985d384f15d7c530e6}\label{class_memory_1_1_safe_shared_ptr_a35960731d11d54985d384f15d7c530e6}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$>$=()}{operator>=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator$>$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{lhs,  }\item[{std\+::nullptr\+\_\+t}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of lhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily nullptr} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily !(lhs \texorpdfstring{$<$}{<} nullptr)}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a Safe\+Shared\+Ptrcreated using the aliasing constructor. 
\end{DoxyNote}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a264f33cced46d07bd154bf3dcaa19725}\label{class_memory_1_1_safe_shared_ptr_a264f33cced46d07bd154bf3dcaa19725}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$>$=()}{operator>=()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \\
bool operator$>$= (\begin{DoxyParamCaption}\item[{std\+::nullptr\+\_\+t}]{lhs,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Compare {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} object with another input. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of rhs. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & The left-\/hand {\ttfamily nullptr} to compare. \\
\hline
{\em rhs} & The right-\/hand {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily !(nullptr \texorpdfstring{$<$}{<} rhs)}.
\end{DoxyReturn}
The comparison operators for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} simply compare pointer values; the actual objects pointed to are not compared. Having operator\texorpdfstring{$<$}{<} defined for {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} allows {\ttfamily \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}} to be used as keys in associative containers, like {\ttfamily std\+::map} and {\ttfamily std\+::set}. \begin{DoxyNote}{Note}
In all cases, it is the stored pointer (the one returned by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get()}}) that is compared, rather than the managed pointer (the one passed to the deleter when use\+\_\+count goes to zero). The two pointers may differ in a Safe\+Shared\+Ptrcreated using the aliasing constructor. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a4084b69baf9080919bc1e980026d8922}{get}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a9e2e3789aedc31bd3ffd12d7d82df700}\label{class_memory_1_1_safe_shared_ptr_a9e2e3789aedc31bd3ffd12d7d82df700}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}} , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} , typename OStream $>$ \\
OStream \& operator$<$$<$ (\begin{DoxyParamCaption}\item[{OStream \&}]{os,  }\item[{const \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Outputs the value of the stored pointer to an output stream. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of object managed by \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Safe\+Shared\+Ptr}} \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, will auto-\/deduct from input. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, will auto-\/deduct from input. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, will auto-\/deduct from input. \\
\hline
{\em OStream} & Type of output stream. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em os} & An output stream supports output pointer type. \\
\hline
{\em ptr} & The data to be inserted into os. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
os
\end{DoxyReturn}
Inserts the value of the pointer stored in {\ttfamily ptr} into the output stream {\ttfamily os}.~\newline
 Equivalent to {\ttfamily os \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} ptr.\+get()}. \mbox{\Hypertarget{class_memory_1_1_safe_shared_ptr_a6aa42f7da4280c4574b5024a132691d1}\label{class_memory_1_1_safe_shared_ptr_a6aa42f7da4280c4574b5024a132691d1}} 
\index{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}!swap@{swap}}
\index{swap@{swap}!Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$@{Memory::SafeSharedPtr$<$ T, mutex\_t, read\_lock\_t, write\_lock\_t $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily template$<$typename T , typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}  = Memory\+::shared\+\_\+mutex\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}  = Memory\+::shared\+\_\+lock\+\_\+t, typename \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}}  = Memory\+::unique\+\_\+lock\+\_\+t$>$ \\
void swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{lhs,  }\item[{\mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}$<$ T, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_ad96e006426ca7d988bcfbbc9dd6f7f34}{Shared\+Mutex}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_af087e5e01fc2dc8c0f684c3fd44ba01b}{Shared\+Lock}}, \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr_a307b37022dad9f3be04d444c2552197e}{Unique\+Lock}} $>$ \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [related]}}



Specializes the {\ttfamily std\+::swap} algorithm. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Element type of input shared pointers. \\
\hline
{\em Shared\+Mutex} & Type of the mutex used, default is shared\+\_\+mutex\+\_\+t. \\
\hline
{\em Shared\+Lock} & Type of the read-\/lock used, default is shared\+\_\+lock\+\_\+t. \\
\hline
{\em Unique\+Lock} & Type of the write-\/lock used, default is unique\+\_\+lock\+\_\+t. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em lhs} & Shared pointer whose contents to swap. \\
\hline
{\em rhs} & Another shared pointer whose contents to swap.\\
\hline
\end{DoxyParams}
Specializes the {\ttfamily std\+::swap} algorithm for \mbox{\hyperlink{class_memory_1_1_safe_shared_ptr}{Memory\+::\+Safe\+Shared\+Ptr}}. Swaps the pointers of {\ttfamily lhs} and {\ttfamily rhs}. Calls {\ttfamily lhs.\+swap(rhs)}.

{\bfseries{Complexity}}~\newline
 Constant. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/\+Utilities/\+Memory\+Safety/\mbox{\hyperlink{_safe_shared_ptr_8hpp}{Safe\+Shared\+Ptr.\+hpp}}\end{DoxyCompactItemize}
